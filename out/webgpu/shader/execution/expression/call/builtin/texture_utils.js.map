{"version":3,"file":"texture_utils.js","names":["assert","range","unreachable","isCompressedFloatTextureFormat","isCompressedTextureFormat","isDepthOrStencilTextureFormat","isDepthTextureFormat","isStencilTextureFormat","kEncodableTextureFormats","kTextureFormatInfo","GPUTest","align","clamp","dotProduct","hashU32","lcm","lerp","quantizeToF32","effectiveViewDimensionForDimension","physicalMipSizeFromTexture","reifyTextureDescriptor","virtualMipSize","kTexelRepresentationInfo","TexelComponent","TexelView","createTextureFromTexelViews","reifyExtent3D","kSampleTypeInfo","f32","format","i32","u32","getTextureTypeForTextureViewDimension","viewDimension","is32Float","skipIfNeedsFilteringAndIsUnfilterableOrSelectDevice","t","filter","features","Set","add","feature","skipIf","type","color","size","selectDeviceOrSkipTestCase","Array","from","isFillable","endsWith","isPotentiallyFilterableAndFillable","canPotentiallyFilter","skipIfTextureFormatNotSupportedNotAvailableOrNotFilterable","skipIfTextureFormatNotSupported","info","selectDeviceForTextureFormatOrSkipTestCase","kMipGradientSteps","s_deviceToMipGradientValues","WeakMap","initMipGradientValuesForDevice","device","weights","get","module","createShaderModule","code","pipeline","createRenderPipeline","layout","vertex","fragment","targets","target","createTextureTracked","usage","GPUTextureUsage","RENDER_ATTACHMENT","texture","TEXTURE_BINDING","COPY_DST","mipLevelCount","queue","writeTexture","mipLevel","Uint8Array","bytesPerRow","sampler","createSampler","minFilter","magFilter","mipmapFilter","storageBuffer","createBufferTracked","GPUBufferUsage","STORAGE","COPY_SRC","resultBuffer","MAP_READ","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","createView","buffer","encoder","createCommandEncoder","pass","beginRenderPass","colorAttachments","view","loadOp","storeOp","setPipeline","setBindGroup","draw","end","copyBufferToBuffer","submit","finish","mapAsync","GPUMapMode","READ","Float32Array","getMappedRange","unmap","destroy","showWeights","map","v","i","toString","padStart","join","Math","abs","set","getWeightForMipLevel","steps","length","w","lowerNdx","floor","upperNdx","ceil","mix","WGSLTextureQueryTest","executeAndExpectResult","expected","createComputePipeline","compute","beginComputePass","dispatchWorkgroups","e","Uint32Array","expectGPUBufferValuesEqual","WGSLTextureSampleTest","init","getLimitValue","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","getValueBetweenMinAndMaxTexelValueInclusive","rep","component","normalized","numericRange","perComponentRanges","perComponentRange","min","max","getTexelViewFormatForTextureFormat","kTextureTypeInfo","depth","componentType","resultType","resultFormat","float","sint","uint","getTextureFormatTypeInfo","stencil","appendComponentTypeForFormatToTextureType","base","includes","createRandomTexelView","generator","coords","texel","componentOrder","rnd","x","y","z","sampleIndex","charCodeAt","width","height","depthOrArrayLayers","quantize","fromTexelsAsColors","createRandomTexelViewMipmap","dimension","kTextureCallArgNames","isBuiltinComparison","builtin","isBuiltinGather","builtinNeedsSampler","startsWith","isCubeViewDimension","viewDescriptor","s_u32","s_f32","s_i32","Int32Array","kBitCastFunctions","f","u","getCallArgType","call","argName","coordType","undefined","levelType","arrayIndexType","sampleIndexType","toArray","repl","bitsToNumber","unpackBits","pack","encode","apply","a","b","op","getUnusedCubeCornerSampleIndex","textureSize","convertPerTexelComponentToResultFormat","src","out","R","G","B","A","convertResultFormatToTexelViewFormat","zeroValuePerTexelComponent","components","kSamplerFns","never","ref","less","equal","less-equal","greater","not-equal","greater-equal","always","applyCompare","depthRef","compareFn","compare","softwareTextureReadMipLevel","texels","descriptor","addressMode","addressModeU","addressModeV","addressModeW","isCube","arrayIndexMult","numLayers","textureSizeForCube","load","at","zFromArrayIndex","arrayIndex","convertCubeCoordToNormalized3DTextureCoord","offset","samples","p0","p1","p1W","p0W","push","weight","ndx","describeTextureCall","p","round","componentNdx","kRGBAComponents","forEach","sample","c","wrapFaceCoordToCubeFaceAtEdgeBoundaries","applyAddressModesToCoords","postV","rgba","isOutOfBoundsCall","softwareTextureReadLevel","maxLevel","effectiveMipmapFilter","clampedMipLevel","baseMipLevel","nextMipLevel","t0","t1","values","softwareTextureRead","ddx","ddy","texSize","scaledDdx","scaledDdy","dotDDX","dotDDY","deltaMax","log2","desc","sampleCount","isValidOutOfBoundsValue","gotRGBA","maxFractionalDiff","mipTexels","texelsApproximatelyEqual","okBecauseOutOfBounds","kRComponent","expectRGBA","got","expect","gULP","bitsToULPFromZero","numberToBits","eULP","rgbaComponentsToCheck","g","absDiff","ulpDiff","getULPFromZeroForComponents","temp","comp","ulp","checkCallResults","textureType","calls","results","errs","getMaxFractionalDiffForTextureFormat","callIdx","bad","diffs","isNaN","maxAbs","relDiff","isFloatType","fix5","n","toFixed","fix5v","arr","rgbaToArray","coord","faceNdx","mipSize","slice","kFaceNames","expectedSamplePoints","identifySamplePoints","Promise","resolve","gotSamplePoints","gpuTexture","createTextureFromTexelViewsLocal","result","doTextureCalls","layoutTwoColumns","Error","softwareRasterize","targetSize","options","uvwStart","screenSpaceUMult","screenSpaceVMult","expData","fragY","fragX","asRgba32Float","fromTextureDataByReference","rowsPerImage","subrectOrigin","subrectSize","drawTexture","samplerDesc","renderTarget","uMult","vMult","offsetWGSL","shaderModule","primitive","topology","renderPass","checkTextureMatchesExpectedTexelView","actualTexture","expectedTexelView","expectTexelViewComparisonIsOkInTexture","putDataInTextureThenDrawAndCheckResultsComparedToSoftwareRasterizer","createTextureWithRandomDataAndGetTexels","sumOfCharCodesOfString","s","String","split","reduce","sum","makeAstcBlockFiller","bytesPerBlock","bytes","data","hashBase","makeRandomBytesBlockFiller","getBlockFiller","fillTextureWithRandomData","fillBlock","blocksAcross","blockWidth","blocksDown","blockHeight","bytesNeeded","s_readTextureToRGBA32DeviceToPipeline","getEffectiveViewDimension","textureBindingViewDimension","readTextureToTexelViews","viewDimensionToPipelineMap","Map","id","textureWGSL","loadWGSL","dimensionWGSL","readBuffers","uniformValues","uniformBuffer","byteLength","UNIFORM","writeBuffer","readBuffer","texelViews","modifiedDescriptor","valueIfAllComponentsAreEqual","next","value","createVideoFrameWithRandomDataAndGetTexels","imageData","ImageData","asU32","canvas","OffscreenCanvas","ctx","getContext","putImageData","videoFrame","VideoFrame","timestamp","alpha","run","mipLevelSize","numTexelsPerLevel","numTexelsOfPrecedingLevels","total","num","numTexels","convertResultAsAppropriate","sampledTexelWeights","unclassifiedStack","unclassified","pop","setA","setB","keys","texelsPerSlice","texelsPerRow","texelId","isCandidate","has","some","getMipLevelFromTexelId","levels","level","layer","layerEntries","xyId","lines","letter","idx","fromCodePoint","idCount","orderedTexelIndices","unSampled","line","padEnd","texelIdx","pad2","singleWeight","columnA","columnB","widthA","l","repeat","getDepthOrArrayLayersForViewDimension","chooseTextureSize","minSize","minBlocks","blockLCM","largest","kSamplePointMethods","kCubeSamplePointMethods","generateTextureBuiltinInputsImpl","makeValue","args","method","r","radius","loops","PI","cos","sin","_hashInputs","hashInputs","makeRangeValue","number","makeIntHashValueRepeatable","kSubdivisionsPerTexel","avoidEdgeCase","textureBuiltin","edgeRemainder","numComponents","quantizeMipLevel","q","v1","isEdgeCase","v2","_","j","kMipEpsilon","intMip","fractionalMip","generateTextureBuiltinInputs1D","generateTextureBuiltinInputs2D","generateTextureBuiltinInputs3D","kFaceUVMatrices","transformMat3","m","normalize","sqrt","uvw","absR","negX","negY","negZ","convertNormalized3DTexCoordToCubeCoord","uvLayer","faceLayer","faceCoord","nc0","cc","nc1","fc","generateSamplePointsCube","textureWidth","face","theta","phi","sinTheta","cosTheta","sinPhi","cosPhi","ux","uy","uz","makeIntHashValue","halfTexel","quantizedUVW","wgslTypeFor","isArray","wgslExpr","wgslExprFor","binKey","name","buildBinnedCalls","fields","prototype","bitcastToU32","expr","binCalls","bins","key","binIdx","s_deviceToPipelines","GPUExternalTexture","structs","body","dataFields","callCount","binned","dataBuffer","isCompare","returnType","samplerType","rtWidth","pipelines","isFiltering","sampleType","visibility","GPUShaderStage","FRAGMENT","storageTexture","access","externalTexture","multisampled","JSON","stringify","bindGroupLayout","createBindGroupLayout","createPipelineLayout","bindGroupLayouts","createRenderPipelineAsync","gpuSampler","copyTextureToBuffer","outIdx","bin"],"sources":["../../../../../../../src/webgpu/shader/execution/expression/call/builtin/texture_utils.ts"],"sourcesContent":["import { assert, range, unreachable } from '../../../../../../common/util/util.js';\nimport {\n  EncodableTextureFormat,\n  isCompressedFloatTextureFormat,\n  isCompressedTextureFormat,\n  isDepthOrStencilTextureFormat,\n  isDepthTextureFormat,\n  isStencilTextureFormat,\n  kEncodableTextureFormats,\n  kTextureFormatInfo,\n} from '../../../../../format_info.js';\nimport {\n  GPUTest,\n  GPUTestSubcaseBatchState,\n  TextureTestMixinType,\n} from '../../../../../gpu_test.js';\nimport {\n  align,\n  clamp,\n  dotProduct,\n  hashU32,\n  lcm,\n  lerp,\n  quantizeToF32,\n} from '../../../../../util/math.js';\nimport {\n  effectiveViewDimensionForDimension,\n  physicalMipSizeFromTexture,\n  reifyTextureDescriptor,\n  SampleCoord,\n  virtualMipSize,\n} from '../../../../../util/texture/base.js';\nimport {\n  kTexelRepresentationInfo,\n  NumericRange,\n  PerComponentNumericRange,\n  PerTexelComponent,\n  TexelComponent,\n  TexelRepresentationInfo,\n} from '../../../../../util/texture/texel_data.js';\nimport { TexelView } from '../../../../../util/texture/texel_view.js';\nimport { createTextureFromTexelViews } from '../../../../../util/texture.js';\nimport { reifyExtent3D } from '../../../../../util/unions.js';\n\nexport type SampledType = 'f32' | 'i32' | 'u32';\n\nexport const kSampleTypeInfo = {\n  f32: {\n    format: 'rgba8unorm',\n  },\n  i32: {\n    format: 'rgba8sint',\n  },\n  u32: {\n    format: 'rgba8uint',\n  },\n} as const;\n\n/**\n * Return the texture type for a given view dimension\n */\nexport function getTextureTypeForTextureViewDimension(viewDimension: GPUTextureViewDimension) {\n  switch (viewDimension) {\n    case '1d':\n      return 'texture_1d<f32>';\n    case '2d':\n      return 'texture_2d<f32>';\n    case '2d-array':\n      return 'texture_2d_array<f32>';\n    case '3d':\n      return 'texture_3d<f32>';\n    case 'cube':\n      return 'texture_cube<f32>';\n    case 'cube-array':\n      return 'texture_cube_array<f32>';\n    default:\n      unreachable();\n  }\n}\n\nconst is32Float = (format: GPUTextureFormat) =>\n  format === 'r32float' || format === 'rg32float' || format === 'rgba32float';\n\n/**\n * Skips a subcase if the filter === 'linear' and the format is type\n * 'unfilterable-float' and we cannot enable filtering.\n */\nexport function skipIfNeedsFilteringAndIsUnfilterableOrSelectDevice(\n  t: GPUTestSubcaseBatchState,\n  filter: GPUFilterMode,\n  format: GPUTextureFormat\n) {\n  const features = new Set<GPUFeatureName | undefined>();\n  features.add(kTextureFormatInfo[format].feature);\n\n  if (filter === 'linear') {\n    t.skipIf(isDepthTextureFormat(format), 'depth texture are unfilterable');\n\n    const type = kTextureFormatInfo[format].color?.type;\n    if (type === 'unfilterable-float') {\n      assert(is32Float(format));\n      features.add('float32-filterable');\n    }\n  }\n\n  if (features.size > 0) {\n    t.selectDeviceOrSkipTestCase(Array.from(features));\n  }\n}\n\n/**\n * Returns if a texture format can be filled with random data.\n */\nexport function isFillable(format: GPUTextureFormat) {\n  // We can't easily put random bytes into compressed textures if they are float formats\n  // since we want the range to be +/- 1000 and not +/- infinity or NaN.\n  return !isCompressedTextureFormat(format) || !format.endsWith('float');\n}\n\n/**\n * Returns if a texture format can potentially be filtered and can be filled with random data.\n */\nexport function isPotentiallyFilterableAndFillable(format: GPUTextureFormat) {\n  const type = kTextureFormatInfo[format].color?.type;\n  const canPotentiallyFilter = type === 'float' || type === 'unfilterable-float';\n  return canPotentiallyFilter && isFillable(format);\n}\n\n/**\n * skips the test if the texture format is not supported or not available or not filterable.\n */\nexport function skipIfTextureFormatNotSupportedNotAvailableOrNotFilterable(\n  t: GPUTestSubcaseBatchState,\n  format: GPUTextureFormat\n) {\n  t.skipIfTextureFormatNotSupported(format);\n  const info = kTextureFormatInfo[format];\n  if (info.color?.type === 'unfilterable-float') {\n    t.selectDeviceOrSkipTestCase('float32-filterable');\n  } else {\n    t.selectDeviceForTextureFormatOrSkipTestCase(format);\n  }\n}\n\n/**\n * Gets the mip gradient values for the current device.\n * The issue is, different GPUs have different ways of mixing between mip levels.\n * For most GPUs it's linear but for AMD GPUs on Mac in particular, it's something\n * else (which AFAICT is against all the specs).\n *\n * We seemingly have 3 options:\n *\n * 1. Increase the tolerances of tests so they pass on AMD.\n * 2. Mark AMD as failing\n * 3. Try to figure out how the GPU converts mip levels into weights\n *\n * We're doing 3.\n *\n * There's an assumption that the gradient will be the same for all formats\n * and usages.\n */\nconst kMipGradientSteps = 16;\nconst s_deviceToMipGradientValues = new WeakMap<GPUDevice, number[]>();\nasync function initMipGradientValuesForDevice(t: GPUTest) {\n  const { device } = t;\n  const weights = s_deviceToMipGradientValues.get(device);\n  if (!weights) {\n    const module = device.createShaderModule({\n      code: `\n        @group(0) @binding(0) var tex: texture_2d<f32>;\n        @group(0) @binding(1) var smp: sampler;\n        @group(0) @binding(2) var<storage, read_write> result: array<f32>;\n\n        @vertex fn vs(@builtin(vertex_index) vNdx: u32) -> @builtin(position) vec4f {\n          let pos = array(\n            vec2f(-1,  3),\n            vec2f( 3, -1),\n            vec2f(-1, -1),\n          );\n          return vec4f(pos[vNdx], 0, 1);\n        }\n        @fragment fn fs(@builtin(position) pos: vec4f) -> @location(0) vec4f {\n          let mipLevel = floor(pos.x) / ${kMipGradientSteps};\n          result[u32(pos.x)] = textureSampleLevel(tex, smp, vec2f(0.5), mipLevel).r;\n          return vec4f(0);\n        }\n      `,\n    });\n\n    const pipeline = device.createRenderPipeline({\n      layout: 'auto',\n      vertex: { module },\n      fragment: { module, targets: [{ format: 'rgba8unorm' }] },\n    });\n\n    const target = t.createTextureTracked({\n      size: [kMipGradientSteps + 1, 1, 1],\n      format: 'rgba8unorm',\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    const texture = t.createTextureTracked({\n      size: [2, 2, 1],\n      format: 'r8unorm',\n      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,\n      mipLevelCount: 2,\n    });\n\n    device.queue.writeTexture(\n      { texture, mipLevel: 1 },\n      new Uint8Array([255]),\n      { bytesPerRow: 1 },\n      [1, 1]\n    );\n\n    const sampler = device.createSampler({\n      minFilter: 'linear',\n      magFilter: 'linear',\n      mipmapFilter: 'linear',\n    });\n\n    const storageBuffer = t.createBufferTracked({\n      size: 4 * (kMipGradientSteps + 1),\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n\n    const resultBuffer = t.createBufferTracked({\n      size: storageBuffer.size,\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n    });\n\n    const bindGroup = device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        { binding: 0, resource: texture.createView() },\n        { binding: 1, resource: sampler },\n        { binding: 2, resource: { buffer: storageBuffer } },\n      ],\n    });\n\n    const encoder = device.createCommandEncoder();\n    const pass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: target.createView(),\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.draw(3);\n    pass.end();\n    encoder.copyBufferToBuffer(storageBuffer, 0, resultBuffer, 0, resultBuffer.size);\n    device.queue.submit([encoder.finish()]);\n\n    await resultBuffer.mapAsync(GPUMapMode.READ);\n    const weights = Array.from(new Float32Array(resultBuffer.getMappedRange()));\n    resultBuffer.unmap();\n\n    texture.destroy();\n    storageBuffer.destroy();\n    resultBuffer.destroy();\n\n    const showWeights = () => weights.map((v, i) => `${i.toString().padStart(2)}: ${v}`).join('\\n');\n\n    // Validate the weights\n    assert(weights[0] === 0, `weight 0 expected 0 but was ${weights[0]}\\n${showWeights()}`);\n    assert(\n      weights[kMipGradientSteps] === 1,\n      `top weight expected 1 but was ${weights[kMipGradientSteps]}\\n${showWeights()}`\n    );\n    assert(\n      Math.abs(weights[kMipGradientSteps / 2] - 0.5) < 0.0001,\n      `middle weight expected approximately 0.5 but was ${\n        weights[kMipGradientSteps / 2]\n      }\\n${showWeights()}`\n    );\n\n    // Note: for 16 steps, these are the AMD weights\n    //\n    //                 standard\n    // step  mipLevel    gpu        AMD\n    // ----  --------  --------  ----------\n    //  0:   0         0           0\n    //  1:   0.0625    0.0625      0\n    //  2:   0.125     0.125       0.03125\n    //  3:   0.1875    0.1875      0.109375\n    //  4:   0.25      0.25        0.1875\n    //  5:   0.3125    0.3125      0.265625\n    //  6:   0.375     0.375       0.34375\n    //  7:   0.4375    0.4375      0.421875\n    //  8:   0.5       0.5         0.5\n    //  9:   0.5625    0.5625      0.578125\n    // 10:   0.625     0.625       0.65625\n    // 11:   0.6875    0.6875      0.734375\n    // 12:   0.75      0.75        0.8125\n    // 13:   0.8125    0.8125      0.890625\n    // 14:   0.875     0.875       0.96875\n    // 15:   0.9375    0.9375      1\n    // 16:   1         1           1\n    //\n    // notice step 1 is 0 and step 15 is 1.\n    // so we only check the 1 through 14.\n    for (let i = 1; i < kMipGradientSteps - 1; ++i) {\n      assert(weights[i] < weights[i + 1]);\n    }\n\n    s_deviceToMipGradientValues.set(device, weights);\n  }\n}\n\nfunction getWeightForMipLevel(t: GPUTest, mipLevelCount: number, mipLevel: number) {\n  if (mipLevel < 0 || mipLevel >= mipLevelCount) {\n    return 1;\n  }\n  // linear interpolate between weights\n  const weights = s_deviceToMipGradientValues.get(t.device);\n  assert(\n    !!weights,\n    'you must use WGSLTextureSampleTest or call initializeDeviceMipWeights before calling this function'\n  );\n  const steps = weights.length - 1;\n  const w = (mipLevel % 1) * steps;\n  const lowerNdx = Math.floor(w);\n  const upperNdx = Math.ceil(w);\n  const mix = w % 1;\n  return lerp(weights[lowerNdx], weights[upperNdx], mix);\n}\n\n/**\n * Used for textureDimension, textureNumLevels, textureNumLayers\n */\nexport class WGSLTextureQueryTest extends GPUTest {\n  executeAndExpectResult(code: string, view: GPUTextureView, expected: number[]) {\n    const { device } = this;\n    const module = device.createShaderModule({ code });\n    const pipeline = device.createComputePipeline({\n      layout: 'auto',\n      compute: {\n        module,\n      },\n    });\n\n    const resultBuffer = this.createBufferTracked({\n      size: 16,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n\n    const bindGroup = device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        { binding: 0, resource: view },\n        { binding: 1, resource: { buffer: resultBuffer } },\n      ],\n    });\n\n    const encoder = device.createCommandEncoder();\n    const pass = encoder.beginComputePass();\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.dispatchWorkgroups(1);\n    pass.end();\n    device.queue.submit([encoder.finish()]);\n\n    const e = new Uint32Array(4);\n    e.set(expected);\n    this.expectGPUBufferValuesEqual(resultBuffer, e);\n  }\n}\n\n/**\n * Used for textureSampleXXX\n */\nexport class WGSLTextureSampleTest extends GPUTest {\n  override async init(): Promise<void> {\n    await super.init();\n    await initMipGradientValuesForDevice(this);\n  }\n}\n\n/**\n * Used to specify a range from [0, num)\n * The type is used to determine if values should be integers and if they can be negative.\n */\nexport type RangeDef = {\n  num: number;\n  type: 'f32' | 'i32' | 'u32';\n};\n\nfunction getLimitValue(v: number) {\n  switch (v) {\n    case Number.POSITIVE_INFINITY:\n      return 1000;\n    case Number.NEGATIVE_INFINITY:\n      return -1000;\n    default:\n      return v;\n  }\n}\n\nfunction getValueBetweenMinAndMaxTexelValueInclusive(\n  rep: TexelRepresentationInfo,\n  component: TexelComponent,\n  normalized: number\n) {\n  assert(!!rep.numericRange);\n  const perComponentRanges = rep.numericRange as PerComponentNumericRange;\n  const perComponentRange = perComponentRanges[component];\n  const range = rep.numericRange as NumericRange;\n  const { min, max } = perComponentRange ? perComponentRange : range;\n  return lerp(getLimitValue(min), getLimitValue(max), normalized);\n}\n\n/**\n * We need the software rendering to do the same interpolation as the hardware\n * rendered so for -srgb formats we set the TexelView to an -srgb format as\n * TexelView handles this case. Note: It might be nice to add rgba32float-srgb\n * or something similar to TexelView.\n */\nexport function getTexelViewFormatForTextureFormat(format: GPUTextureFormat) {\n  return format.endsWith('-srgb') ? 'rgba8unorm-srgb' : 'rgba32float';\n}\n\nconst kTextureTypeInfo = {\n  depth: {\n    componentType: 'f32',\n    resultType: 'vec4f',\n    resultFormat: 'rgba32float',\n  },\n  float: {\n    componentType: 'f32',\n    resultType: 'vec4f',\n    resultFormat: 'rgba32float',\n  },\n  'unfilterable-float': {\n    componentType: 'f32',\n    resultType: 'vec4f',\n    resultFormat: 'rgba32float',\n  },\n  sint: {\n    componentType: 'i32',\n    resultType: 'vec4i',\n    resultFormat: 'rgba32sint',\n  },\n  uint: {\n    componentType: 'u32',\n    resultType: 'vec4u',\n    resultFormat: 'rgba32uint',\n  },\n} as const;\n\nfunction getTextureFormatTypeInfo(format: GPUTextureFormat) {\n  const info = kTextureFormatInfo[format];\n  const type = info.color?.type ?? info.depth?.type ?? info.stencil?.type;\n  assert(!!type);\n  return kTextureTypeInfo[type];\n}\n\n/**\n * given a texture type 'base', returns the base with the correct component for the given texture format.\n * eg: `getTextureType('texture_2d', someUnsignedIntTextureFormat)` -> `texture_2d<u32>`\n */\nexport function appendComponentTypeForFormatToTextureType(base: string, format: GPUTextureFormat) {\n  return base.includes('depth')\n    ? base\n    : `${base}<${getTextureFormatTypeInfo(format).componentType}>`;\n}\n\n/**\n * Creates a TexelView filled with random values.\n */\nexport function createRandomTexelView(info: {\n  format: GPUTextureFormat;\n  size: GPUExtent3D;\n  mipLevel: number;\n}): TexelView {\n  const rep = kTexelRepresentationInfo[info.format as EncodableTextureFormat];\n  const size = reifyExtent3D(info.size);\n  const generator = (coords: SampleCoord): Readonly<PerTexelComponent<number>> => {\n    const texel: PerTexelComponent<number> = {};\n    for (const component of rep.componentOrder) {\n      const rnd = hashU32(\n        coords.x,\n        coords.y,\n        coords.z,\n        coords.sampleIndex ?? 0,\n        component.charCodeAt(0),\n        info.mipLevel,\n        size.width,\n        size.height,\n        size.depthOrArrayLayers\n      );\n      const normalized = clamp(rnd / 0xffffffff, { min: 0, max: 1 });\n      texel[component] = getValueBetweenMinAndMaxTexelValueInclusive(rep, component, normalized);\n    }\n    return quantize(texel, rep);\n  };\n  return TexelView.fromTexelsAsColors(info.format as EncodableTextureFormat, generator);\n}\n\n/**\n * Creates a mip chain of TexelViews filled with random values\n */\nexport function createRandomTexelViewMipmap(info: {\n  format: GPUTextureFormat;\n  size: GPUExtent3D;\n  mipLevelCount?: number;\n  dimension?: GPUTextureDimension;\n}): TexelView[] {\n  const mipLevelCount = info.mipLevelCount ?? 1;\n  const dimension = info.dimension ?? '2d';\n  return range(mipLevelCount, i =>\n    createRandomTexelView({\n      format: info.format,\n      size: virtualMipSize(dimension, info.size, i),\n      mipLevel: i,\n    })\n  );\n}\n\nexport type vec1 = [number]; // Because it's easy to deal with if these types are all array of number\nexport type vec2 = [number, number];\nexport type vec3 = [number, number, number];\nexport type vec4 = [number, number, number, number];\nexport type Dimensionality = vec1 | vec2 | vec3;\n\ntype TextureCallArgKeys = keyof TextureCallArgs<vec1>;\nconst kTextureCallArgNames: readonly TextureCallArgKeys[] = [\n  'component',\n  'coords',\n  'arrayIndex',\n  'sampleIndex',\n  'mipLevel',\n  'ddx',\n  'ddy',\n  'depthRef',\n  'offset',\n] as const;\n\nexport interface TextureCallArgs<T extends Dimensionality> {\n  component?: number;\n  coords?: T;\n  mipLevel?: number;\n  arrayIndex?: number;\n  sampleIndex?: number;\n  depthRef?: number;\n  ddx?: T;\n  ddy?: T;\n  offset?: T;\n}\n\nexport type TextureBuiltin =\n  | 'textureGather'\n  | 'textureGatherCompare'\n  | 'textureLoad'\n  | 'textureSample'\n  | 'textureSampleBaseClampToEdge'\n  | 'textureSampleLevel';\n\nexport interface TextureCall<T extends Dimensionality> extends TextureCallArgs<T> {\n  builtin: TextureBuiltin;\n  coordType: 'f' | 'i' | 'u';\n  levelType?: 'i' | 'u' | 'f';\n  arrayIndexType?: 'i' | 'u';\n  sampleIndexType?: 'i' | 'u';\n  componentType?: 'i' | 'u';\n}\n\nconst isBuiltinComparison = (builtin: TextureBuiltin) => builtin === 'textureGatherCompare';\nconst isBuiltinGather = (builtin: TextureBuiltin | undefined) =>\n  builtin === 'textureGather' || builtin === 'textureGatherCompare';\nconst builtinNeedsSampler = (builtin: TextureBuiltin) =>\n  builtin.startsWith('textureSample') || builtin.startsWith('textureGather');\n\nconst isCubeViewDimension = (viewDescriptor?: GPUTextureViewDescriptor) =>\n  viewDescriptor?.dimension === 'cube' || viewDescriptor?.dimension === 'cube-array';\n\nconst s_u32 = new Uint32Array(1);\nconst s_f32 = new Float32Array(s_u32.buffer);\nconst s_i32 = new Int32Array(s_u32.buffer);\n\nconst kBitCastFunctions = {\n  f: (v: number) => {\n    s_f32[0] = v;\n    return s_u32[0];\n  },\n  i: (v: number) => {\n    s_i32[0] = v;\n    assert(s_i32[0] === v, 'check we are not casting non-int or out-of-range value');\n    return s_u32[0];\n  },\n  u: (v: number) => {\n    s_u32[0] = v;\n    assert(s_u32[0] === v, 'check we are not casting non-uint or out-of-range value');\n    return s_u32[0];\n  },\n};\n\nfunction getCallArgType<T extends Dimensionality>(\n  call: TextureCall<T>,\n  argName: (typeof kTextureCallArgNames)[number]\n) {\n  switch (argName) {\n    case 'coords':\n      return call.coordType;\n    case 'component':\n      assert(call.componentType !== undefined);\n      return call.componentType;\n    case 'mipLevel':\n      assert(call.levelType !== undefined);\n      return call.levelType;\n    case 'arrayIndex':\n      assert(call.arrayIndexType !== undefined);\n      return call.arrayIndexType;\n    case 'sampleIndex':\n      assert(call.sampleIndexType !== undefined);\n      return call.sampleIndexType;\n    case 'depthRef':\n    case 'ddx':\n    case 'ddy':\n      return 'f';\n    default:\n      unreachable();\n  }\n}\n\nfunction toArray(coords: Dimensionality): number[] {\n  if (coords instanceof Array) {\n    return coords;\n  }\n  return [coords];\n}\n\nfunction quantize(texel: PerTexelComponent<number>, repl: TexelRepresentationInfo) {\n  return repl.bitsToNumber(repl.unpackBits(new Uint8Array(repl.pack(repl.encode(texel)))));\n}\n\nfunction apply(a: number[], b: number[], op: (x: number, y: number) => number) {\n  assert(a.length === b.length, `apply(${a}, ${b}): arrays must have same length`);\n  return a.map((v, i) => op(v, b[i]));\n}\n\n/**\n * At the corner of a cubemap we need to sample just 3 texels, not 4.\n * The texels are in\n *\n *   0:  (u,v)\n *   1:  (u + 1, v)\n *   2:  (u, v + 1)\n *   3:  (u + 1, v + 1)\n *\n * We pass in the original 2d (converted from cubemap) texture coordinate.\n * If it's within half a pixel of the edge in both directions then it's\n * a corner so we return the index of the one texel that's not needed.\n * Otherwise we return -1.\n */\nfunction getUnusedCubeCornerSampleIndex(textureSize: number, coords: vec3) {\n  const u = coords[0] * textureSize;\n  const v = coords[1] * textureSize;\n  if (v < 0.5) {\n    if (u < 0.5) {\n      return 0;\n    } else if (u >= textureSize - 0.5) {\n      return 1;\n    }\n  } else if (v >= textureSize - 0.5) {\n    if (u < 0.5) {\n      return 2;\n    } else if (u >= textureSize - 0.5) {\n      return 3;\n    }\n  }\n  return -1;\n}\n\nconst add = (a: number[], b: number[]) => apply(a, b, (x, y) => x + y);\n\nexport interface Texture {\n  texels: TexelView[];\n  descriptor: GPUTextureDescriptor;\n  viewDescriptor: GPUTextureViewDescriptor;\n}\n\n/**\n * Converts the src texel representation to an RGBA representation.\n */\nfunction convertPerTexelComponentToResultFormat(\n  src: PerTexelComponent<number>,\n  format: EncodableTextureFormat\n): PerTexelComponent<number> {\n  const rep = kTexelRepresentationInfo[format];\n  const out: PerTexelComponent<number> = { R: 0, G: 0, B: 0, A: 1 };\n  for (const component of rep.componentOrder) {\n    switch (component) {\n      case 'Stencil':\n      case 'Depth':\n        out.R = src[component];\n        break;\n      default:\n        assert(out[component] !== undefined); // checks that component = R, G, B or A\n        out[component] = src[component];\n    }\n  }\n  return out;\n}\n\n/**\n * Convert RGBA result format to texel view format of src texture.\n * Effectively this converts something like { R: 0.1, G: 0, B: 0, A: 1 }\n * to { Depth: 0.1 }\n */\nfunction convertResultFormatToTexelViewFormat(\n  src: PerTexelComponent<number>,\n  format: EncodableTextureFormat\n): PerTexelComponent<number> {\n  const rep = kTexelRepresentationInfo[format];\n  const out: PerTexelComponent<number> = {};\n  for (const component of rep.componentOrder) {\n    out[component] = src[component] ?? src.R;\n  }\n  return out;\n}\n\nfunction zeroValuePerTexelComponent(components: TexelComponent[]) {\n  const out: PerTexelComponent<number> = {};\n  for (const component of components) {\n    out[component] = 0;\n  }\n  return out;\n}\n\nconst kSamplerFns: Record<GPUCompareFunction, (ref: number, v: number) => boolean> = {\n  never: (ref: number, v: number) => false,\n  less: (ref: number, v: number) => ref < v,\n  equal: (ref: number, v: number) => ref === v,\n  'less-equal': (ref: number, v: number) => ref <= v,\n  greater: (ref: number, v: number) => ref > v,\n  'not-equal': (ref: number, v: number) => ref !== v,\n  'greater-equal': (ref: number, v: number) => ref >= v,\n  always: (ref: number, v: number) => true,\n} as const;\n\nfunction applyCompare<T extends Dimensionality>(\n  call: TextureCall<T>,\n  sampler: GPUSamplerDescriptor | undefined,\n  components: TexelComponent[],\n  src: PerTexelComponent<number>\n): PerTexelComponent<number> {\n  if (isBuiltinComparison(call.builtin)) {\n    assert(sampler !== undefined);\n    assert(call.depthRef !== undefined);\n    const out: PerTexelComponent<number> = {};\n    const compareFn = kSamplerFns[sampler.compare!];\n    for (const component of components) {\n      out[component] = compareFn(call.depthRef, src[component]!) ? 1 : 0;\n    }\n    return out;\n  } else {\n    return src;\n  }\n}\n\n/**\n * Returns the expect value for a WGSL builtin texture function for a single\n * mip level\n */\nexport function softwareTextureReadMipLevel<T extends Dimensionality>(\n  call: TextureCall<T>,\n  texture: Texture,\n  sampler: GPUSamplerDescriptor | undefined,\n  mipLevel: number\n): PerTexelComponent<number> {\n  assert(mipLevel % 1 === 0);\n  const { format } = texture.texels[0];\n  const rep = kTexelRepresentationInfo[format];\n  const textureSize = virtualMipSize(\n    texture.descriptor.dimension || '2d',\n    texture.descriptor.size,\n    mipLevel\n  );\n  const addressMode: GPUAddressMode[] =\n    call.builtin === 'textureSampleBaseClampToEdge'\n      ? ['clamp-to-edge', 'clamp-to-edge', 'clamp-to-edge']\n      : [\n          sampler?.addressModeU ?? 'clamp-to-edge',\n          sampler?.addressModeV ?? 'clamp-to-edge',\n          sampler?.addressModeW ?? 'clamp-to-edge',\n        ];\n\n  const isCube = isCubeViewDimension(texture.viewDescriptor);\n  const arrayIndexMult = isCube ? 6 : 1;\n  const numLayers = textureSize[2] / arrayIndexMult;\n  assert(numLayers % 1 === 0);\n  const textureSizeForCube = [textureSize[0], textureSize[1], 6];\n\n  const load = (at: number[]) => {\n    const zFromArrayIndex =\n      call.arrayIndex !== undefined\n        ? clamp(call.arrayIndex, { min: 0, max: numLayers - 1 }) * arrayIndexMult\n        : 0;\n    return texture.texels[mipLevel].color({\n      x: Math.floor(at[0]),\n      y: Math.floor(at[1] ?? 0),\n      z: Math.floor(at[2] ?? 0) + zFromArrayIndex,\n      sampleIndex: call.sampleIndex,\n    });\n  };\n\n  switch (call.builtin) {\n    case 'textureGather':\n    case 'textureGatherCompare':\n    case 'textureSample':\n    case 'textureSampleBaseClampToEdge':\n    case 'textureSampleLevel': {\n      let coords = toArray(call.coords!);\n\n      if (isCube) {\n        coords = convertCubeCoordToNormalized3DTextureCoord(coords as vec3);\n      }\n\n      // convert normalized to absolute texel coordinate\n      // ┌───┬───┬───┬───┐\n      // │ a │   │   │   │  norm: a = 1/8, b = 7/8\n      // ├───┼───┼───┼───┤   abs: a = 0,   b = 3\n      // │   │   │   │   │\n      // ├───┼───┼───┼───┤\n      // │   │   │   │   │\n      // ├───┼───┼───┼───┤\n      // │   │   │   │ b │\n      // └───┴───┴───┴───┘\n      let at = coords.map((v, i) => v * (isCube ? textureSizeForCube : textureSize)[i] - 0.5);\n\n      // Apply offset in whole texel units\n      // This means the offset is added at each mip level in texels. There's no\n      // scaling for each level.\n      if (call.offset !== undefined) {\n        at = add(at, toArray(call.offset));\n      }\n\n      const samples: { at: number[]; weight: number }[] = [];\n\n      const filter = isBuiltinGather(call.builtin) ? 'linear' : sampler?.minFilter ?? 'nearest';\n      switch (filter) {\n        case 'linear': {\n          // 'p0' is the lower texel for 'at'\n          const p0 = at.map(v => Math.floor(v));\n          // 'p1' is the higher texel for 'at'\n          // If it's cube then don't advance Z.\n          const p1 = p0.map((v, i) => v + (isCube ? (i === 2 ? 0 : 1) : 1));\n\n          // interpolation weights for p0 and p1\n          const p1W = at.map((v, i) => v - p0[i]);\n          const p0W = p1W.map(v => 1 - v);\n\n          switch (coords.length) {\n            case 1:\n              samples.push({ at: p0, weight: p0W[0] });\n              samples.push({ at: p1, weight: p1W[0] });\n              break;\n            case 2: {\n              // Note: These are ordered to match textureGather\n              samples.push({ at: [p0[0], p1[1]], weight: p0W[0] * p1W[1] });\n              samples.push({ at: p1, weight: p1W[0] * p1W[1] });\n              samples.push({ at: [p1[0], p0[1]], weight: p1W[0] * p0W[1] });\n              samples.push({ at: p0, weight: p0W[0] * p0W[1] });\n              break;\n            }\n            case 3: {\n              // cube sampling, here in the software renderer, is the same\n              // as 2d sampling. We'll sample at most 4 texels. The weights are\n              // the same as if it was just one plane. If the points fall outside\n              // the slice they'll be wrapped by wrapFaceCoordToCubeFaceAtEdgeBoundaries\n              // below.\n              if (isCube) {\n                // Note: These are ordered to match textureGather\n                samples.push({ at: [p0[0], p1[1], p0[2]], weight: p0W[0] * p1W[1] });\n                samples.push({ at: p1, weight: p1W[0] * p1W[1] });\n                samples.push({ at: [p1[0], p0[1], p0[2]], weight: p1W[0] * p0W[1] });\n                samples.push({ at: p0, weight: p0W[0] * p0W[1] });\n                const ndx = getUnusedCubeCornerSampleIndex(textureSize[0], coords as vec3);\n                if (ndx >= 0) {\n                  // # Issues with corners of cubemaps\n                  //\n                  // note: I tried multiple things here\n                  //\n                  // 1. distribute 1/3 of the weight of the removed sample to each of the remaining samples\n                  // 2. distribute 1/2 of the weight of the removed sample to the 2 samples that are not the \"main\" sample.\n                  // 3. normalize the weights of the remaining 3 samples.\n                  //\n                  // none of them matched the M1 in all cases. Checking the dEQP I found this comment\n                  //\n                  // > If any of samples is out of both edges, implementations can do pretty much anything according to spec.\n                  // https://github.com/KhronosGroup/VK-GL-CTS/blob/d2d6aa65607383bb29c8398fe6562c6b08b4de57/framework/common/tcuTexCompareVerifier.cpp#L882\n                  //\n                  // If I understand this correctly it matches the OpenGL ES 3.1 spec it says\n                  // it's implementation defined.\n                  //\n                  // > OpenGL ES 3.1 section 8.12.1 Seamless Cubemap Filtering\n                  // >\n                  // > -  If a texture sample location would lie in the texture\n                  // >    border in both u and v (in one of the corners of the\n                  // >    cube), there is no unique neighboring face from which to\n                  // >    extract one texel. The recommended method to generate this\n                  // >    texel is to average the values of the three available\n                  // >    samples. However, implementations are free to construct\n                  // >    this fourth texel in another way, so long as, when the\n                  // >    three available samples have the same value, this texel\n                  // >    also has that value.\n                  //\n                  // I'm not sure what \"average the values of the three available samples\"\n                  // means. To me that would be (a+b+c)/3 or in other words, set all the\n                  // weights to 0.33333 but that's not what the M1 is doing.\n                  //\n                  // We could check that, given the 3 texels at the corner, if all 3 texels\n                  // are the same value then the result must be the same value. Otherwise,\n                  // the result must be between the 3 values. For now, the code that\n                  // chooses test coordinates avoids corners. This has the restriction\n                  // that the smallest mip level be at least 4x4 so there are some non\n                  // corners to choose from.\n                  unreachable(\n                    `corners of cubemaps are not testable:\\n   ${describeTextureCall(call)}`\n                  );\n                }\n              } else {\n                const p = [p0, p1];\n                const w = [p0W, p1W];\n                for (let z = 0; z < 2; ++z) {\n                  for (let y = 0; y < 2; ++y) {\n                    for (let x = 0; x < 2; ++x) {\n                      samples.push({\n                        at: [p[x][0], p[y][1], p[z][2]],\n                        weight: w[x][0] * w[y][1] * w[z][2],\n                      });\n                    }\n                  }\n                }\n              }\n              break;\n            }\n          }\n          break;\n        }\n        case 'nearest': {\n          const p = at.map(v => Math.round(quantizeToF32(v)));\n          samples.push({ at: p, weight: 1 });\n          break;\n        }\n        default:\n          unreachable();\n      }\n\n      if (isBuiltinGather(call.builtin)) {\n        const componentNdx = call.component ?? 0;\n        assert(componentNdx >= 0 && componentNdx < 4);\n        assert(samples.length === 4);\n        const component = kRGBAComponents[componentNdx];\n        const out: PerTexelComponent<number> = {};\n        samples.forEach((sample, i) => {\n          const c = isCube\n            ? wrapFaceCoordToCubeFaceAtEdgeBoundaries(textureSize[0], sample.at as vec3)\n            : applyAddressModesToCoords(addressMode, textureSize, sample.at);\n          const v = load(c);\n          const postV = applyCompare(call, sampler, rep.componentOrder, v);\n          const rgba = convertPerTexelComponentToResultFormat(postV, format);\n          out[kRGBAComponents[i]] = rgba[component];\n        });\n        return out;\n      }\n\n      const out: PerTexelComponent<number> = {};\n      for (const sample of samples) {\n        const c = isCube\n          ? wrapFaceCoordToCubeFaceAtEdgeBoundaries(textureSize[0], sample.at as vec3)\n          : applyAddressModesToCoords(addressMode, textureSize, sample.at);\n        const v = load(c);\n        const postV = applyCompare(call, sampler, rep.componentOrder, v);\n        for (const component of rep.componentOrder) {\n          out[component] = (out[component] ?? 0) + postV[component]! * sample.weight;\n        }\n      }\n\n      return convertPerTexelComponentToResultFormat(out, format);\n    }\n    case 'textureLoad': {\n      const out: PerTexelComponent<number> = isOutOfBoundsCall(texture, call)\n        ? zeroValuePerTexelComponent(rep.componentOrder)\n        : load(call.coords!);\n      return convertPerTexelComponentToResultFormat(out, format);\n    }\n    default:\n      unreachable();\n  }\n}\n\n/**\n * Reads a texture, optionally sampling between 2 mipLevels\n */\nexport function softwareTextureReadLevel<T extends Dimensionality>(\n  t: GPUTest,\n  call: TextureCall<T>,\n  texture: Texture,\n  sampler: GPUSamplerDescriptor | undefined,\n  mipLevel: number\n): PerTexelComponent<number> {\n  const mipLevelCount = texture.texels.length;\n  const maxLevel = mipLevelCount - 1;\n\n  if (!sampler) {\n    return softwareTextureReadMipLevel<T>(call, texture, sampler, mipLevel);\n  }\n\n  const effectiveMipmapFilter = isBuiltinGather(call.builtin) ? 'nearest' : sampler.mipmapFilter;\n  switch (effectiveMipmapFilter) {\n    case 'linear': {\n      const clampedMipLevel = clamp(mipLevel, { min: 0, max: maxLevel });\n      const baseMipLevel = Math.floor(clampedMipLevel);\n      const nextMipLevel = Math.ceil(clampedMipLevel);\n      const t0 = softwareTextureReadMipLevel<T>(call, texture, sampler, baseMipLevel);\n      const t1 = softwareTextureReadMipLevel<T>(call, texture, sampler, nextMipLevel);\n      const mix = getWeightForMipLevel(t, mipLevelCount, mipLevel);\n      const values = [\n        { v: t0, weight: 1 - mix },\n        { v: t1, weight: mix },\n      ];\n      const out: PerTexelComponent<number> = {};\n      for (const { v, weight } of values) {\n        for (const component of kRGBAComponents) {\n          out[component] = (out[component] ?? 0) + v[component]! * weight;\n        }\n      }\n      return out;\n    }\n    default: {\n      const baseMipLevel = Math.floor(\n        clamp(mipLevel + 0.5, { min: 0, max: texture.texels.length - 1 })\n      );\n      return softwareTextureReadMipLevel<T>(call, texture, sampler, baseMipLevel);\n    }\n  }\n}\n\n/**\n * The software version of a texture builtin (eg: textureSample)\n * Note that this is not a complete implementation. Rather it's only\n * what's needed to generate the correct expected value for the tests.\n */\nexport function softwareTextureRead<T extends Dimensionality>(\n  t: GPUTest,\n  call: TextureCall<T>,\n  texture: Texture,\n  sampler: GPUSamplerDescriptor\n): PerTexelComponent<number> {\n  assert(call.ddx !== undefined);\n  assert(call.ddy !== undefined);\n  const texSize = reifyExtent3D(texture.descriptor.size);\n  const textureSize = [texSize.width, texSize.height];\n\n  // ddx and ddy are the values that would be passed to textureSampleGrad\n  // If we're emulating textureSample then they're the computed derivatives\n  // such that if we passed them to textureSampleGrad they'd produce the\n  // same result.\n  const ddx: readonly number[] = typeof call.ddx === 'number' ? [call.ddx] : call.ddx;\n  const ddy: readonly number[] = typeof call.ddy === 'number' ? [call.ddy] : call.ddy;\n\n  // Compute the mip level the same way textureSampleGrad does\n  const scaledDdx = ddx.map((v, i) => v * textureSize[i]);\n  const scaledDdy = ddy.map((v, i) => v * textureSize[i]);\n  const dotDDX = dotProduct(scaledDdx, scaledDdx);\n  const dotDDY = dotProduct(scaledDdy, scaledDdy);\n  const deltaMax = Math.max(dotDDX, dotDDY);\n  // MAINTENANCE_TODO: handle texture view baseMipLevel and mipLevelCount?\n  const mipLevel = 0.5 * Math.log2(deltaMax);\n  return softwareTextureReadLevel(t, call, texture, sampler, mipLevel);\n}\n\nexport type TextureTestOptions = {\n  ddx?: number; // the derivative we want at sample time\n  ddy?: number;\n  uvwStart?: readonly [number, number]; // the starting uv value (these are used make the coordinates negative as it uncovered issues on some hardware)\n  offset?: readonly [number, number]; // a constant offset\n};\n\n/**\n * out of bounds is defined as any of the following being true\n *\n * * coords is outside the range [0, textureDimensions(t, level))\n * * array_index is outside the range [0, textureNumLayers(t))\n * * level is outside the range [0, textureNumLevels(t))\n * * sample_index is outside the range [0, textureNumSamples(s))\n */\nfunction isOutOfBoundsCall<T extends Dimensionality>(texture: Texture, call: TextureCall<T>) {\n  assert(call.coords !== undefined);\n\n  const desc = reifyTextureDescriptor(texture.descriptor);\n  const { coords, mipLevel, arrayIndex, sampleIndex } = call;\n\n  if (mipLevel !== undefined && (mipLevel < 0 || mipLevel >= desc.mipLevelCount)) {\n    return true;\n  }\n\n  const size = virtualMipSize(\n    texture.descriptor.dimension || '2d',\n    texture.descriptor.size,\n    mipLevel ?? 0\n  );\n\n  for (let i = 0; i < coords.length; ++i) {\n    const v = coords[i];\n    if (v < 0 || v >= size[i]) {\n      return true;\n    }\n  }\n\n  if (arrayIndex !== undefined) {\n    const size = reifyExtent3D(desc.size);\n    if (arrayIndex < 0 || arrayIndex >= size.depthOrArrayLayers) {\n      return true;\n    }\n  }\n\n  if (sampleIndex !== undefined) {\n    if (sampleIndex < 0 || sampleIndex >= desc.sampleCount) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction isValidOutOfBoundsValue(\n  texture: Texture,\n  gotRGBA: PerTexelComponent<number>,\n  maxFractionalDiff: number\n) {\n  // For a texture builtin with no sampler (eg textureLoad),\n  // any out of bounds access is allowed to return one of:\n  //\n  // * the value of any texel in the texture\n  // * 0,0,0,0 or 0,0,0,1 if not a depth texture\n  // * 0 if a depth texture\n  if (texture.descriptor.format.includes('depth')) {\n    if (gotRGBA.R === 0) {\n      return true;\n    }\n  } else {\n    if (\n      gotRGBA.R === 0 &&\n      gotRGBA.B === 0 &&\n      gotRGBA.G === 0 &&\n      (gotRGBA.A === 0 || gotRGBA.A === 1)\n    ) {\n      return true;\n    }\n  }\n\n  // Can be any texel value\n  for (let mipLevel = 0; mipLevel < texture.texels.length; ++mipLevel) {\n    const mipTexels = texture.texels[mipLevel];\n    const size = virtualMipSize(\n      texture.descriptor.dimension || '2d',\n      texture.descriptor.size,\n      mipLevel\n    );\n    const sampleCount = texture.descriptor.sampleCount ?? 1;\n    for (let z = 0; z < size[2]; ++z) {\n      for (let y = 0; y < size[1]; ++y) {\n        for (let x = 0; x < size[0]; ++x) {\n          for (let sampleIndex = 0; sampleIndex < sampleCount; ++sampleIndex) {\n            const texel = mipTexels.color({ x, y, z, sampleIndex });\n            const rgba = convertPerTexelComponentToResultFormat(texel, mipTexels.format);\n            if (texelsApproximatelyEqual(gotRGBA, rgba, mipTexels.format, maxFractionalDiff)) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * For a texture builtin with no sampler (eg textureLoad),\n * any out of bounds access is allowed to return one of:\n *\n * * the value of any texel in the texture\n * * 0,0,0,0 or 0,0,0,1 if not a depth texture\n * * 0 if a depth texture\n */\nfunction okBecauseOutOfBounds<T extends Dimensionality>(\n  texture: Texture,\n  call: TextureCall<T>,\n  gotRGBA: PerTexelComponent<number>,\n  maxFractionalDiff: number\n) {\n  if (!isOutOfBoundsCall(texture, call)) {\n    return false;\n  }\n\n  return isValidOutOfBoundsValue(texture, gotRGBA, maxFractionalDiff);\n}\n\nconst kRGBAComponents = [\n  TexelComponent.R,\n  TexelComponent.G,\n  TexelComponent.B,\n  TexelComponent.A,\n] as const;\n\nconst kRComponent = [TexelComponent.R] as const;\n\nfunction texelsApproximatelyEqual(\n  gotRGBA: PerTexelComponent<number>,\n  expectRGBA: PerTexelComponent<number>,\n  format: EncodableTextureFormat,\n  maxFractionalDiff: number\n) {\n  const rep = kTexelRepresentationInfo[format];\n  const got = convertResultFormatToTexelViewFormat(gotRGBA, format);\n  const expect = convertResultFormatToTexelViewFormat(expectRGBA, format);\n  const gULP = convertPerTexelComponentToResultFormat(\n    rep.bitsToULPFromZero(rep.numberToBits(got)),\n    format\n  );\n  const eULP = convertPerTexelComponentToResultFormat(\n    rep.bitsToULPFromZero(rep.numberToBits(expect)),\n    format\n  );\n\n  const rgbaComponentsToCheck = isDepthOrStencilTextureFormat(format)\n    ? kRComponent\n    : kRGBAComponents;\n\n  for (const component of rgbaComponentsToCheck) {\n    const g = gotRGBA[component]!;\n    const e = expectRGBA[component]!;\n    const absDiff = Math.abs(g - e);\n    const ulpDiff = Math.abs(gULP[component]! - eULP[component]!);\n    if (ulpDiff > 3 && absDiff > maxFractionalDiff) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// If it's `textureGather` then we need to convert all values to one component.\n// In other words, imagine the format is rg11b10ufloat. If it was\n// `textureSample` we'd have `r11, g11, b10, a=1` but for `textureGather`\n//\n// component = 0 => `r11, r11, r11, r11`\n// component = 1 => `g11, g11, g11, g11`\n// component = 2 => `b10, b10, b10, b10`\n//\n// etc..., each from a different texel\n//\n// The Texel utils don't handle this. So if `component = 2` we take each value,\n// copy it to the `B` component, run it through the texel utils so it returns\n// the correct ULP for a 10bit float (not an 11 bit float). Then copy it back to\n// the channel it came from.\nfunction getULPFromZeroForComponents(\n  rgba: PerTexelComponent<number>,\n  format: EncodableTextureFormat,\n  builtin: TextureBuiltin,\n  componentNdx?: number\n): PerTexelComponent<number> {\n  const rep = kTexelRepresentationInfo[format];\n  if (isBuiltinGather(builtin)) {\n    const out: PerTexelComponent<number> = {};\n    const component = kRGBAComponents[componentNdx ?? 0];\n    const temp: PerTexelComponent<number> = { R: 0, G: 0, B: 0, A: 1 };\n    for (const comp of kRGBAComponents) {\n      temp[component] = rgba[comp];\n      const texel = convertResultFormatToTexelViewFormat(temp, format);\n      const ulp = convertPerTexelComponentToResultFormat(\n        rep.bitsToULPFromZero(rep.numberToBits(texel)),\n        format\n      );\n      out[comp] = ulp[component];\n    }\n    return out;\n  } else {\n    const texel = convertResultFormatToTexelViewFormat(rgba, format);\n    return convertPerTexelComponentToResultFormat(\n      rep.bitsToULPFromZero(rep.numberToBits(texel)),\n      format\n    );\n  }\n}\n\n/**\n * Checks the result of each call matches the expected result.\n */\nexport async function checkCallResults<T extends Dimensionality>(\n  t: GPUTest,\n  texture: Texture,\n  textureType: string,\n  sampler: GPUSamplerDescriptor | undefined,\n  calls: TextureCall<T>[],\n  results: PerTexelComponent<number>[]\n) {\n  const errs: string[] = [];\n  const format = texture.texels[0].format;\n  const size = reifyExtent3D(texture.descriptor.size);\n  const maxFractionalDiff =\n    sampler?.minFilter === 'linear' ||\n    sampler?.magFilter === 'linear' ||\n    sampler?.mipmapFilter === 'linear'\n      ? getMaxFractionalDiffForTextureFormat(texture.descriptor.format)\n      : 0;\n\n  for (let callIdx = 0; callIdx < calls.length; callIdx++) {\n    const call = calls[callIdx];\n    const gotRGBA = results[callIdx];\n    const expectRGBA = softwareTextureReadLevel(t, call, texture, sampler, call.mipLevel ?? 0);\n\n    // The spec says depth and stencil have implementation defined values for G, B, and A\n    // so if this is `textureGather` and component > 0 then there's nothing to check.\n    if (\n      isDepthOrStencilTextureFormat(format) &&\n      isBuiltinGather(call.builtin) &&\n      call.component! > 0\n    ) {\n      continue;\n    }\n\n    if (texelsApproximatelyEqual(gotRGBA, expectRGBA, format, maxFractionalDiff)) {\n      continue;\n    }\n\n    if (!sampler && okBecauseOutOfBounds(texture, call, gotRGBA, maxFractionalDiff)) {\n      continue;\n    }\n\n    const gULP = getULPFromZeroForComponents(gotRGBA, format, call.builtin, call.component);\n    const eULP = getULPFromZeroForComponents(expectRGBA, format, call.builtin, call.component);\n\n    // from the spec: https://gpuweb.github.io/gpuweb/#reading-depth-stencil\n    // depth and stencil values are D, ?, ?, ?\n    const rgbaComponentsToCheck =\n      isBuiltinGather(call.builtin) || !isDepthOrStencilTextureFormat(format)\n        ? kRGBAComponents\n        : kRComponent;\n\n    let bad = false;\n    const diffs = rgbaComponentsToCheck.map(component => {\n      const g = gotRGBA[component]!;\n      const e = expectRGBA[component]!;\n      const absDiff = Math.abs(g - e);\n      const ulpDiff = Math.abs(gULP[component]! - eULP[component]!);\n      assert(!Number.isNaN(ulpDiff));\n      const maxAbs = Math.max(Math.abs(g), Math.abs(e));\n      const relDiff = maxAbs > 0 ? absDiff / maxAbs : 0;\n      if (ulpDiff > 3 && absDiff > maxFractionalDiff) {\n        bad = true;\n      }\n      return { absDiff, relDiff, ulpDiff };\n    });\n\n    const isFloatType = (format: GPUTextureFormat) => {\n      const info = kTextureFormatInfo[format];\n      return info.color?.type === 'float' || info.depth?.type === 'depth';\n    };\n    const fix5 = (n: number) => (isFloatType(format) ? n.toFixed(5) : n.toString());\n    const fix5v = (arr: number[]) => arr.map(v => fix5(v)).join(', ');\n    const rgbaToArray = (p: PerTexelComponent<number>): number[] =>\n      rgbaComponentsToCheck.map(component => p[component]!);\n\n    if (bad) {\n      const desc = describeTextureCall(call);\n      errs.push(`result was not as expected:\n      size: [${size.width}, ${size.height}, ${size.depthOrArrayLayers}]\n  mipCount: ${texture.descriptor.mipLevelCount ?? 1}\n      call: ${desc}  // #${callIdx}`);\n      if (isCubeViewDimension(texture.viewDescriptor)) {\n        const coord = convertCubeCoordToNormalized3DTextureCoord(call.coords as vec3);\n        const faceNdx = Math.floor(coord[2] * 6);\n        errs.push(`          : as 3D texture coord: (${coord[0]}, ${coord[1]}, ${coord[2]})`);\n        for (let mipLevel = 0; mipLevel < (texture.descriptor.mipLevelCount ?? 1); ++mipLevel) {\n          const mipSize = virtualMipSize(\n            texture.descriptor.dimension ?? '2d',\n            texture.descriptor.size,\n            mipLevel\n          );\n          const t = coord.slice(0, 2).map((v, i) => (v * mipSize[i]).toFixed(3));\n          errs.push(\n            `          : as texel coord mip level[${mipLevel}]: (${t[0]}, ${t[1]}), face: ${faceNdx}(${kFaceNames[faceNdx]})`\n          );\n        }\n      } else {\n        for (let mipLevel = 0; mipLevel < (texture.descriptor.mipLevelCount ?? 1); ++mipLevel) {\n          const mipSize = virtualMipSize(\n            texture.descriptor.dimension ?? '2d',\n            texture.descriptor.size,\n            mipLevel\n          );\n          const t = call.coords!.map((v, i) => (v * mipSize[i]).toFixed(3));\n          errs.push(`          : as texel coord @ mip level[${mipLevel}]: (${t.join(', ')})`);\n        }\n      }\n      errs.push(`\\\n       got: ${fix5v(rgbaToArray(gotRGBA))}\n  expected: ${fix5v(rgbaToArray(expectRGBA))}\n  max diff: ${maxFractionalDiff}\n abs diffs: ${fix5v(diffs.map(({ absDiff }) => absDiff))}\n rel diffs: ${diffs.map(({ relDiff }) => `${(relDiff * 100).toFixed(2)}%`).join(', ')}\n ulp diffs: ${diffs.map(({ ulpDiff }) => ulpDiff).join(', ')}\n`);\n\n      if (sampler) {\n        const expectedSamplePoints = [\n          'expected:',\n          ...(await identifySamplePoints(texture, call, (texels: TexelView[]) => {\n            return Promise.resolve(\n              softwareTextureReadLevel(\n                t,\n                call,\n                {\n                  texels,\n                  descriptor: texture.descriptor,\n                  viewDescriptor: texture.viewDescriptor,\n                },\n                sampler,\n                call.mipLevel ?? 0\n              )\n            );\n          })),\n        ];\n        const gotSamplePoints = [\n          'got:',\n          ...(await identifySamplePoints(texture, call, async (texels: TexelView[]) => {\n            const gpuTexture = createTextureFromTexelViewsLocal(t, texels, texture.descriptor);\n            const result = (\n              await doTextureCalls(t, gpuTexture, texture.viewDescriptor, textureType, sampler, [\n                call,\n              ])\n            )[0];\n            gpuTexture.destroy();\n            return result;\n          })),\n        ];\n        errs.push('  sample points:');\n        errs.push(layoutTwoColumns(expectedSamplePoints, gotSamplePoints).join('\\n'));\n        errs.push('', '');\n\n        // This path is slow so if we took it, don't report the other errors. One is enough\n        // to fail the test.\n        break;\n      } // if (sampler)\n    } // if (bad)\n  } // for cellNdx\n\n  return errs.length > 0 ? new Error(errs.join('\\n')) : undefined;\n}\n\n/**\n * \"Renders a quad\" to a TexelView with the given parameters,\n * sampling from the given Texture.\n */\nexport function softwareRasterize<T extends Dimensionality>(\n  t: GPUTest,\n  texture: Texture,\n  sampler: GPUSamplerDescriptor,\n  targetSize: [number, number],\n  options: TextureTestOptions\n) {\n  const [width, height] = targetSize;\n  const { ddx = 1, ddy = 1, uvwStart = [0, 0] } = options;\n  const format = 'rgba32float';\n\n  const textureSize = reifyExtent3D(texture.descriptor.size);\n\n  // MAINTENANCE_TODO: Consider passing these in as a similar computation\n  // happens in putDataInTextureThenDrawAndCheckResultsComparedToSoftwareRasterizer.\n  // The issue is there, the calculation is \"what do we need to multiply the unitQuad\n  // by to get the derivatives we want\". The calculation here is \"what coordinate\n  // will we get for a given frag coordinate\". It turns out to be the same calculation\n  // but needs rephrasing them so they are more obviously the same would help\n  // consolidate them into one calculation.\n  const screenSpaceUMult = (ddx * width) / textureSize.width;\n  const screenSpaceVMult = (ddy * height) / textureSize.height;\n\n  const rep = kTexelRepresentationInfo[format];\n\n  const expData = new Float32Array(width * height * 4);\n  for (let y = 0; y < height; ++y) {\n    const fragY = height - y - 1 + 0.5;\n    for (let x = 0; x < width; ++x) {\n      const fragX = x + 0.5;\n      // This code calculates the same value that will be passed to\n      // `textureSample` in the fragment shader for a given frag coord (see the\n      // WGSL code which uses the same formula, but using interpolation). That\n      // shader renders a clip space quad and includes a inter-stage \"uv\"\n      // coordinates that start with a unit quad (0,0) to (1,1) and is\n      // multiplied by ddx,ddy and as added in uStart and vStart\n      //\n      // uv = unitQuad * vec2(ddx, ddy) + vec2(vStart, uStart);\n      //\n      // softwareTextureRead<T> simulates a single call to `textureSample` so\n      // here we're computing the `uv` value that will be passed for a\n      // particular fragment coordinate. fragX / width, fragY / height provides\n      // the unitQuad value.\n      //\n      // ddx and ddy in this case are the derivative values we want to test. We\n      // pass those into the softwareTextureRead<T> as they would normally be\n      // derived from the change in coord.\n      const coords = [\n        (fragX / width) * screenSpaceUMult + uvwStart[0],\n        (fragY / height) * screenSpaceVMult + uvwStart[1],\n      ] as T;\n      const call: TextureCall<T> = {\n        builtin: 'textureSample',\n        coordType: 'f',\n        coords,\n        ddx: [ddx / textureSize.width, 0] as T,\n        ddy: [0, ddy / textureSize.height] as T,\n        offset: options.offset as T,\n      };\n      const sample = softwareTextureRead<T>(t, call, texture, sampler);\n      const rgba = { R: 0, G: 0, B: 0, A: 1, ...sample };\n      const asRgba32Float = new Float32Array(rep.pack(rgba));\n      expData.set(asRgba32Float, (y * width + x) * 4);\n    }\n  }\n\n  return TexelView.fromTextureDataByReference(format, new Uint8Array(expData.buffer), {\n    bytesPerRow: width * 4 * 4,\n    rowsPerImage: height,\n    subrectOrigin: [0, 0, 0],\n    subrectSize: targetSize,\n  });\n}\n\n/**\n * Render textured quad to an rgba32float texture.\n */\nexport function drawTexture(\n  t: GPUTest & TextureTestMixinType,\n  texture: GPUTexture,\n  samplerDesc: GPUSamplerDescriptor,\n  options: TextureTestOptions\n) {\n  const device = t.device;\n  const { ddx = 1, ddy = 1, uvwStart = [0, 0, 0], offset } = options;\n\n  const format = 'rgba32float';\n  const renderTarget = t.createTextureTracked({\n    format,\n    size: [32, 32],\n    usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n  });\n\n  // Compute the amount we need to multiply the unitQuad by get the\n  // derivatives we want.\n  const uMult = (ddx * renderTarget.width) / texture.width;\n  const vMult = (ddy * renderTarget.height) / texture.height;\n\n  const offsetWGSL = offset ? `, vec2i(${offset[0]},${offset[1]})` : '';\n\n  const code = `\nstruct InOut {\n  @builtin(position) pos: vec4f,\n  @location(0) uv: vec2f,\n};\n\n@vertex fn vs(@builtin(vertex_index) vertex_index : u32) -> InOut {\n  let positions = array(\n    vec2f(-1,  1), vec2f( 1,  1),\n    vec2f(-1, -1), vec2f( 1, -1),\n  );\n  let pos = positions[vertex_index];\n  return InOut(\n    vec4f(pos, 0, 1),\n    (pos * 0.5 + 0.5) * vec2f(${uMult}, ${vMult}) + vec2f(${uvwStart[0]}, ${uvwStart[1]}),\n  );\n}\n\n@group(0) @binding(0) var          T    : texture_2d<f32>;\n@group(0) @binding(1) var          S    : sampler;\n\n@fragment fn fs(v: InOut) -> @location(0) vec4f {\n  return textureSample(T, S, v.uv${offsetWGSL});\n}\n`;\n\n  const shaderModule = device.createShaderModule({ code });\n\n  const pipeline = device.createRenderPipeline({\n    layout: 'auto',\n    vertex: { module: shaderModule },\n    fragment: {\n      module: shaderModule,\n      targets: [{ format }],\n    },\n    primitive: { topology: 'triangle-strip' },\n  });\n\n  const sampler = device.createSampler(samplerDesc);\n\n  const bindGroup = device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: [\n      { binding: 0, resource: texture.createView() },\n      { binding: 1, resource: sampler },\n    ],\n  });\n\n  const encoder = device.createCommandEncoder();\n\n  const renderPass = encoder.beginRenderPass({\n    colorAttachments: [{ view: renderTarget.createView(), loadOp: 'clear', storeOp: 'store' }],\n  });\n\n  renderPass.setPipeline(pipeline);\n  renderPass.setBindGroup(0, bindGroup);\n  renderPass.draw(4);\n  renderPass.end();\n  device.queue.submit([encoder.finish()]);\n\n  return renderTarget;\n}\n\nfunction getMaxFractionalDiffForTextureFormat(format: GPUTextureFormat) {\n  // Note: I'm not sure what we should do here. My assumption is, given texels\n  // have random values, the difference between 2 texels can be very large. In\n  // the current version, for a float texture they can be +/- 1000 difference.\n  // Sampling is very GPU dependent. So if one pixel gets a random value of\n  // -1000 and the neighboring pixel gets +1000 then any slight variation in how\n  // sampling is applied will generate a large difference when interpolating\n  // between -1000 and +1000.\n  //\n  // We could make some entry for every format but for now I just put the\n  // tolerances here based on format texture suffix.\n  //\n  // It's possible the math in the software rasterizer is just bad but the\n  // results certainly seem close.\n  //\n  // These tolerances started from the OpenGL ES dEQP tests.\n  // Those tests always render to an rgba8unorm texture. The shaders do effectively\n  //\n  //   result = textureSample(...) * scale + bias\n  //\n  // to get the results in a 0.0 to 1.0 range. After reading the values back they\n  // expand them to their original ranges with\n  //\n  //   value = (result - bias) / scale;\n  //\n  // Tolerances from dEQP\n  // --------------------\n  // 8unorm: 3.9 / 255\n  // 8snorm: 7.9 / 128\n  // 2unorm: 7.9 / 512\n  // ufloat: 156.249\n  //  float: 31.2498\n  //\n  // The numbers below have been set empirically to get the tests to pass on all\n  // devices. The devices with the most divergence from the calculated expected\n  // values are MacOS Intel and AMD.\n  //\n  // MAINTENANCE_TODO: Double check the software rendering math and lower these\n  // tolerances if possible.\n\n  if (format.includes('depth')) {\n    return 3 / 65536;\n  } else if (format.includes('8unorm')) {\n    return 7 / 255;\n  } else if (format.includes('2unorm')) {\n    return 9 / 512;\n  } else if (format.includes('unorm')) {\n    return 7 / 255;\n  } else if (format.includes('8snorm')) {\n    return 7.9 / 128;\n  } else if (format.includes('snorm')) {\n    return 7.9 / 128;\n  } else if (format.endsWith('ufloat')) {\n    return 156.249;\n  } else if (format.endsWith('float')) {\n    return 44;\n  } else {\n    // It's likely an integer format. In any case, zero tolerance is passable.\n    return 0;\n  }\n}\n\nexport function checkTextureMatchesExpectedTexelView(\n  t: GPUTest & TextureTestMixinType,\n  format: GPUTextureFormat,\n  actualTexture: GPUTexture,\n  expectedTexelView: TexelView\n) {\n  const maxFractionalDiff = getMaxFractionalDiffForTextureFormat(format);\n  t.expectTexelViewComparisonIsOkInTexture(\n    { texture: actualTexture },\n    expectedTexelView,\n    [actualTexture.width, actualTexture.height],\n    { maxFractionalDiff }\n  );\n}\n\n/**\n * Puts data in a texture. Renders a quad to a rgba32float. Then \"software renders\"\n * to a TexelView the expected result and compares the rendered texture to the\n * expected TexelView.\n */\nexport async function putDataInTextureThenDrawAndCheckResultsComparedToSoftwareRasterizer<\n  T extends Dimensionality,\n>(\n  t: GPUTest & TextureTestMixinType,\n  descriptor: GPUTextureDescriptor,\n  viewDescriptor: GPUTextureViewDescriptor,\n  samplerDesc: GPUSamplerDescriptor,\n  options: TextureTestOptions\n) {\n  const { texture, texels } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n\n  const actualTexture = drawTexture(t, texture, samplerDesc, options);\n  const expectedTexelView = softwareRasterize<T>(\n    t,\n    { descriptor, texels, viewDescriptor },\n    samplerDesc,\n    [actualTexture.width, actualTexture.height],\n    options\n  );\n\n  checkTextureMatchesExpectedTexelView(t, texture.format, actualTexture, expectedTexelView);\n}\n\nconst sumOfCharCodesOfString = (s: unknown) =>\n  String(s)\n    .split('')\n    .reduce((sum, c) => sum + c.charCodeAt(0), 0);\n\n/**\n * Makes a function that fills a block portion of a Uint8Array with random valid data\n * for an astc block.\n *\n * The astc format is fairly complicated. For now we do the simplest thing.\n * which is to set the block as a \"void-extent\" block (a solid color).\n * This makes our test have far less precision.\n *\n * MAINTENANCE_TODO: generate other types of astc blocks. One option would\n * be to randomly select from set of pre-made blocks.\n *\n * See Spec:\n * https://registry.khronos.org/OpenGL/extensions/KHR/KHR_texture_compression_astc_hdr.txt\n */\nfunction makeAstcBlockFiller(format: GPUTextureFormat) {\n  const info = kTextureFormatInfo[format];\n  const bytesPerBlock = info.color!.bytes;\n  return (data: Uint8Array, offset: number, hashBase: number) => {\n    // set the block to be a void-extent block\n    data.set(\n      [\n        0b1111_1100, // 0\n        0b1111_1101, // 1\n        0b1111_1111, // 2\n        0b1111_1111, // 3\n        0b1111_1111, // 4\n        0b1111_1111, // 5\n        0b1111_1111, // 6\n        0b1111_1111, // 7\n      ],\n      offset\n    );\n    // fill the rest of the block with random data\n    const end = offset + bytesPerBlock;\n    for (let i = offset + 8; i < end; ++i) {\n      data[i] = hashU32(hashBase, i);\n    }\n  };\n}\n\n/**\n * Makes a function that fills a block portion of a Uint8Array with random bytes.\n */\nfunction makeRandomBytesBlockFiller(format: GPUTextureFormat) {\n  const info = kTextureFormatInfo[format];\n  const bytesPerBlock = info.color!.bytes;\n  return (data: Uint8Array, offset: number, hashBase: number) => {\n    const end = offset + bytesPerBlock;\n    for (let i = offset; i < end; ++i) {\n      data[i] = hashU32(hashBase, i);\n    }\n  };\n}\n\nfunction getBlockFiller(format: GPUTextureFormat) {\n  if (format.startsWith('astc')) {\n    return makeAstcBlockFiller(format);\n  } else {\n    return makeRandomBytesBlockFiller(format);\n  }\n}\n\n/**\n * Fills a texture with random data.\n */\nexport function fillTextureWithRandomData(device: GPUDevice, texture: GPUTexture) {\n  assert(!isCompressedFloatTextureFormat(texture.format));\n  const info = kTextureFormatInfo[texture.format];\n  const hashBase =\n    sumOfCharCodesOfString(texture.format) +\n    sumOfCharCodesOfString(texture.dimension) +\n    texture.width +\n    texture.height +\n    texture.depthOrArrayLayers +\n    texture.mipLevelCount;\n  const bytesPerBlock = info.color!.bytes;\n  const fillBlock = getBlockFiller(texture.format);\n  for (let mipLevel = 0; mipLevel < texture.mipLevelCount; ++mipLevel) {\n    const size = physicalMipSizeFromTexture(texture, mipLevel);\n    const blocksAcross = Math.ceil(size[0] / info.blockWidth);\n    const blocksDown = Math.ceil(size[1] / info.blockHeight);\n    const bytesPerRow = blocksAcross * bytesPerBlock;\n    const bytesNeeded = bytesPerRow * blocksDown * size[2];\n    const data = new Uint8Array(bytesNeeded);\n    for (let offset = 0; offset < bytesNeeded; offset += bytesPerBlock) {\n      fillBlock(data, offset, hashBase);\n    }\n    device.queue.writeTexture(\n      { texture, mipLevel },\n      data,\n      { bytesPerRow, rowsPerImage: blocksDown },\n      size\n    );\n  }\n}\n\nconst s_readTextureToRGBA32DeviceToPipeline = new WeakMap<\n  GPUDevice,\n  Map<string, GPUComputePipeline>\n>();\n\n// MAINTENANCE_TODO: remove cast once textureBindingViewDimension is added to IDL\nfunction getEffectiveViewDimension(\n  t: GPUTest,\n  descriptor: GPUTextureDescriptor\n): GPUTextureViewDimension {\n  const { textureBindingViewDimension } = descriptor as unknown as {\n    textureBindingViewDimension?: GPUTextureViewDimension;\n  };\n  const size = reifyExtent3D(descriptor.size);\n  return effectiveViewDimensionForDimension(\n    textureBindingViewDimension,\n    descriptor.dimension,\n    size.depthOrArrayLayers\n  );\n}\n\nexport async function readTextureToTexelViews(\n  t: GPUTest,\n  texture: GPUTexture,\n  descriptor: GPUTextureDescriptor,\n  format: EncodableTextureFormat\n) {\n  const device = t.device;\n  const viewDimensionToPipelineMap =\n    s_readTextureToRGBA32DeviceToPipeline.get(device) ??\n    new Map<GPUTextureViewDimension, GPUComputePipeline>();\n  s_readTextureToRGBA32DeviceToPipeline.set(device, viewDimensionToPipelineMap);\n\n  const viewDimension = getEffectiveViewDimension(t, descriptor);\n  const id = `${viewDimension}:${texture.sampleCount}`;\n  let pipeline = viewDimensionToPipelineMap.get(id);\n  if (!pipeline) {\n    let textureWGSL;\n    let loadWGSL;\n    let dimensionWGSL = 'textureDimensions(tex, uni.mipLevel)';\n    switch (viewDimension) {\n      case '2d':\n        if (texture.sampleCount > 1) {\n          textureWGSL = 'texture_multisampled_2d<f32>';\n          loadWGSL = 'textureLoad(tex, coord.xy, sampleIndex)';\n          dimensionWGSL = 'textureDimensions(tex)';\n        } else {\n          textureWGSL = 'texture_2d<f32>';\n          loadWGSL = 'textureLoad(tex, coord.xy, mipLevel)';\n        }\n        break;\n      case 'cube-array': // cube-array doesn't exist in compat so we can just use 2d_array for this\n      case '2d-array':\n        textureWGSL = 'texture_2d_array<f32>';\n        loadWGSL = `\n          textureLoad(\n              tex,\n              coord.xy,\n              coord.z,\n              mipLevel)`;\n        break;\n      case '3d':\n        textureWGSL = 'texture_3d<f32>';\n        loadWGSL = 'textureLoad(tex, coord.xyz, mipLevel)';\n        break;\n      case 'cube':\n        textureWGSL = 'texture_cube<f32>';\n        loadWGSL = `\n          textureLoadCubeAs2DArray(tex, coord.xy, coord.z, mipLevel);\n        `;\n        break;\n      default:\n        unreachable(`unsupported view: ${viewDimension}`);\n    }\n    const module = device.createShaderModule({\n      code: `\n        const faceMat = array(\n          mat3x3f( 0,  0,  -2,  0, -2,   0,  1,  1,   1),   // pos-x\n          mat3x3f( 0,  0,   2,  0, -2,   0, -1,  1,  -1),   // neg-x\n          mat3x3f( 2,  0,   0,  0,  0,   2, -1,  1,  -1),   // pos-y\n          mat3x3f( 2,  0,   0,  0,  0,  -2, -1, -1,   1),   // neg-y\n          mat3x3f( 2,  0,   0,  0, -2,   0, -1,  1,   1),   // pos-z\n          mat3x3f(-2,  0,   0,  0, -2,   0,  1,  1,  -1));  // neg-z\n\n        // needed for compat mode.\n        fn textureLoadCubeAs2DArray(tex: texture_cube<f32>, coord: vec2u, layer: u32, mipLevel: u32) -> vec4f {\n          // convert texel coord normalized coord\n          let size = textureDimensions(tex, mipLevel);\n          let uv = (vec2f(coord) + 0.5) / vec2f(size.xy);\n\n          // convert uv + layer into cube coord\n          let cubeCoord = faceMat[layer] * vec3f(uv, 1.0);\n\n          return textureSampleLevel(tex, smp, cubeCoord, f32(mipLevel));\n        }\n\n        struct Uniforms {\n          mipLevel: u32,\n          sampleCount: u32,\n        };\n\n        @group(0) @binding(0) var<uniform> uni: Uniforms;\n        @group(0) @binding(1) var tex: ${textureWGSL};\n        @group(0) @binding(2) var smp: sampler;\n        @group(0) @binding(3) var<storage, read_write> data: array<vec4f>;\n\n        @compute @workgroup_size(1) fn cs(\n          @builtin(global_invocation_id) global_invocation_id : vec3<u32>) {\n          _ = smp;\n          let size = ${dimensionWGSL};\n          let ndx = global_invocation_id.z * size.x * size.y * uni.sampleCount +\n                    global_invocation_id.y * size.x * uni.sampleCount +\n                    global_invocation_id.x;\n          let coord = vec3u(global_invocation_id.x / uni.sampleCount, global_invocation_id.yz);\n          let sampleIndex = global_invocation_id.x % uni.sampleCount;\n          let mipLevel = uni.mipLevel;\n          data[ndx] = ${loadWGSL};\n        }\n      `,\n    });\n    pipeline = device.createComputePipeline({ layout: 'auto', compute: { module } });\n    viewDimensionToPipelineMap.set(id, pipeline);\n  }\n\n  const encoder = device.createCommandEncoder();\n\n  const readBuffers = [];\n  for (let mipLevel = 0; mipLevel < texture.mipLevelCount; ++mipLevel) {\n    const size = virtualMipSize(texture.dimension, texture, mipLevel);\n\n    const uniformValues = new Uint32Array([mipLevel, texture.sampleCount, 0, 0]); // min size is 16 bytes\n    const uniformBuffer = t.createBufferTracked({\n      size: uniformValues.byteLength,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n    device.queue.writeBuffer(uniformBuffer, 0, uniformValues);\n\n    const storageBuffer = t.createBufferTracked({\n      size: size[0] * size[1] * size[2] * 4 * 4 * texture.sampleCount, // rgba32float\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n\n    const readBuffer = t.createBufferTracked({\n      size: storageBuffer.size,\n      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n    });\n    readBuffers.push({ size, readBuffer });\n\n    const sampler = device.createSampler();\n\n    const bindGroup = device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        { binding: 0, resource: { buffer: uniformBuffer } },\n        { binding: 1, resource: texture.createView({ dimension: viewDimension }) },\n        { binding: 2, resource: sampler },\n        { binding: 3, resource: { buffer: storageBuffer } },\n      ],\n    });\n\n    const pass = encoder.beginComputePass();\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.dispatchWorkgroups(size[0] * texture.sampleCount, size[1], size[2]);\n    pass.end();\n    encoder.copyBufferToBuffer(storageBuffer, 0, readBuffer, 0, readBuffer.size);\n  }\n\n  device.queue.submit([encoder.finish()]);\n\n  const texelViews: TexelView[] = [];\n\n  for (const { readBuffer, size } of readBuffers) {\n    await readBuffer.mapAsync(GPUMapMode.READ);\n\n    // need a copy of the data since unmapping will nullify the typedarray view.\n    const data = new Float32Array(readBuffer.getMappedRange()).slice();\n    readBuffer.unmap();\n\n    const { sampleCount } = texture;\n    texelViews.push(\n      TexelView.fromTexelsAsColors(format, coord => {\n        const offset =\n          ((coord.z * size[0] * size[1] + coord.y * size[0] + coord.x) * sampleCount +\n            (coord.sampleIndex ?? 0)) *\n          4;\n        return {\n          R: data[offset + 0],\n          G: data[offset + 1],\n          B: data[offset + 2],\n          A: data[offset + 3],\n        };\n      })\n    );\n  }\n\n  return texelViews;\n}\n\nfunction createTextureFromTexelViewsLocal(\n  t: GPUTest,\n  texelViews: TexelView[],\n  desc: Omit<GPUTextureDescriptor, 'format'>\n): GPUTexture {\n  const modifiedDescriptor = { ...desc };\n  // If it's a depth or stencil texture we need to render to it to fill it with data.\n  if (isDepthOrStencilTextureFormat(texelViews[0].format)) {\n    modifiedDescriptor.usage = desc.usage | GPUTextureUsage.RENDER_ATTACHMENT;\n  }\n  return createTextureFromTexelViews(t, texelViews, modifiedDescriptor);\n}\n\n/**\n * Fills a texture with random data and returns that data as\n * an array of TexelView.\n *\n * For compressed textures the texture is filled with random bytes\n * and then read back from the GPU by sampling so the GPU decompressed\n * the texture.\n *\n * For uncompressed textures the TexelViews are generated and then\n * copied to the texture.\n */\nexport async function createTextureWithRandomDataAndGetTexels(\n  t: GPUTest,\n  descriptor: GPUTextureDescriptor\n) {\n  if (isCompressedTextureFormat(descriptor.format)) {\n    const texture = t.createTextureTracked(descriptor);\n\n    fillTextureWithRandomData(t.device, texture);\n    const texels = await readTextureToTexelViews(\n      t,\n      texture,\n      descriptor,\n      getTexelViewFormatForTextureFormat(texture.format)\n    );\n    return { texture, texels };\n  } else {\n    const texels = createRandomTexelViewMipmap(descriptor);\n    const texture = createTextureFromTexelViewsLocal(t, texels, descriptor);\n    return { texture, texels };\n  }\n}\n\nfunction valueIfAllComponentsAreEqual(\n  c: PerTexelComponent<number>,\n  componentOrder: readonly TexelComponent[]\n) {\n  const s = new Set(componentOrder.map(component => c[component]!));\n  return s.size === 1 ? s.values().next().value : undefined;\n}\n\n/**\n * Creates a VideoFrame with random data and a TexelView with the same data.\n */\nexport function createVideoFrameWithRandomDataAndGetTexels(textureSize: GPUExtent3D) {\n  const size = reifyExtent3D(textureSize);\n  assert(size.depthOrArrayLayers === 1);\n\n  // Fill ImageData with random values.\n  const imageData = new ImageData(size.width, size.height);\n  const data = imageData.data;\n  const asU32 = new Uint32Array(data.buffer);\n  for (let i = 0; i < asU32.length; ++i) {\n    asU32[i] = hashU32(i);\n  }\n\n  // Put the ImageData into a canvas and make a VideoFrame\n  const canvas = new OffscreenCanvas(size.width, size.height);\n  const ctx = canvas.getContext('2d')!;\n  ctx.putImageData(imageData, 0, 0);\n  const videoFrame = new VideoFrame(canvas, { timestamp: 0 });\n\n  // Premultiply the ImageData\n  for (let i = 0; i < data.length; i += 4) {\n    const alpha = data[i + 3] / 255;\n    data[i + 0] = data[i + 0] * alpha;\n    data[i + 1] = data[i + 1] * alpha;\n    data[i + 2] = data[i + 2] * alpha;\n  }\n\n  // Create a TexelView from the premultiplied ImageData\n  const texels = [\n    TexelView.fromTextureDataByReference('rgba8unorm', data, {\n      bytesPerRow: size.width * 4,\n      rowsPerImage: size.height,\n      subrectOrigin: [0, 0, 0],\n      subrectSize: size,\n    }),\n  ];\n\n  return { videoFrame, texels };\n}\n\nconst kFaceNames = ['+x', '-x', '+y', '-y', '+z', '-z'] as const;\n\n/**\n * Generates a text art grid showing which texels were sampled\n * followed by a list of the samples and the weights used for each\n * component.\n *\n * It works by making a set of indices for every texel in the texture.\n * It splits the set into 2. It picks one set and generates texture data\n * using TexelView.fromTexelsAsColor with [1, 1, 1, 1] texels for members\n * of the current set.\n *\n * In then calls 'run' which renders a single `call`. `run` uses either\n * the software renderer or WebGPU. It then checks the results. If the\n * result is zero, all texels in the current had no influence when sampling\n * and can be discarded.\n *\n * If the result is > 0 then, if the set has more than one member, the\n * set is split and added to the list to sets to test. If the set only\n * had one member then the result is the weight used when sampling that texel.\n *\n * This lets you see if the weights from the software renderer match the\n * weights from WebGPU.\n *\n * Example:\n *\n *     0   1   2   3   4   5   6   7\n *   ┌───┬───┬───┬───┬───┬───┬───┬───┐\n * 0 │   │   │   │   │   │   │   │   │\n *   ├───┼───┼───┼───┼───┼───┼───┼───┤\n * 1 │   │   │   │   │   │   │   │ a │\n *   ├───┼───┼───┼───┼───┼───┼───┼───┤\n * 2 │   │   │   │   │   │   │   │ b │\n *   ├───┼───┼───┼───┼───┼───┼───┼───┤\n * 3 │   │   │   │   │   │   │   │   │\n *   ├───┼───┼───┼───┼───┼───┼───┼───┤\n * 4 │   │   │   │   │   │   │   │   │\n *   ├───┼───┼───┼───┼───┼───┼───┼───┤\n * 5 │   │   │   │   │   │   │   │   │\n *   ├───┼───┼───┼───┼───┼───┼───┼───┤\n * 6 │   │   │   │   │   │   │   │   │\n *   ├───┼───┼───┼───┼───┼───┼───┼───┤\n * 7 │   │   │   │   │   │   │   │   │\n *   └───┴───┴───┴───┴───┴───┴───┴───┘\n * a: at: [7, 1], weights: [R: 0.75000]\n * b: at: [7, 2], weights: [R: 0.25000]\n */\nasync function identifySamplePoints<T extends Dimensionality>(\n  texture: Texture,\n  call: TextureCall<T>,\n  run: (texels: TexelView[]) => Promise<PerTexelComponent<number>>\n) {\n  const info = texture.descriptor;\n  const isCube = isCubeViewDimension(texture.viewDescriptor);\n  const mipLevelCount = texture.descriptor.mipLevelCount ?? 1;\n  const mipLevelSize = range(mipLevelCount, mipLevel =>\n    virtualMipSize(texture.descriptor.dimension ?? '2d', texture.descriptor.size, mipLevel)\n  );\n  const numTexelsPerLevel = mipLevelSize.map(size => size.reduce((s, v) => s * v));\n  const numTexelsOfPrecedingLevels = (() => {\n    let total = 0;\n    return numTexelsPerLevel.map(v => {\n      const num = total;\n      total += v;\n      return num;\n    });\n  })();\n  const numTexels = numTexelsPerLevel.reduce((sum, v) => sum + v);\n\n  // This isn't perfect. We already know there was an error. We're just\n  // generating info so it seems okay it's not perfect. This format will\n  // be used to generate weights by drawing with a texture of this format\n  // with a specific pixel set to [1, 1, 1, 1]. As such, if the result\n  // is > 0 then that pixel was sampled and the results are the weights.\n  //\n  // Ideally, this texture with a single pixel set to [1, 1, 1, 1] would\n  // be the same format we were originally testing, the one we already\n  // detected an error for. This way, whatever subtle issues there are\n  // from that format will affect the weight values we're computing. But,\n  // if that format is not encodable, for example if it's a compressed\n  // texture format, then we have no way to build a texture so we use\n  // rgba8unorm instead.\n  const format = (\n    kEncodableTextureFormats.includes(info.format as EncodableTextureFormat)\n      ? info.format\n      : 'rgba8unorm'\n  ) as EncodableTextureFormat;\n  const rep = kTexelRepresentationInfo[format];\n\n  const components = isBuiltinGather(call.builtin) ? kRGBAComponents : rep.componentOrder;\n  const convertResultAsAppropriate = isBuiltinGather(call.builtin)\n    ? <T>(v: T) => v\n    : convertResultFormatToTexelViewFormat;\n\n  // Identify all the texels that are sampled, and their weights.\n  const sampledTexelWeights = new Map<number, PerTexelComponent<number>>();\n  const unclassifiedStack = [new Set<number>(range(numTexels, v => v))];\n  while (unclassifiedStack.length > 0) {\n    // Pop the an unclassified texels stack\n    const unclassified = unclassifiedStack.pop()!;\n\n    // Split unclassified texels evenly into two new sets\n    const setA = new Set<number>();\n    const setB = new Set<number>();\n    [...unclassified.keys()].forEach((t, i) => ((i & 1) === 0 ? setA : setB).add(t));\n\n    // Push setB to the unclassified texels stack\n    if (setB.size > 0) {\n      unclassifiedStack.push(setB);\n    }\n\n    // See if any of the texels in setA were sampled.0\n    const results = convertResultAsAppropriate(\n      await run(\n        range(mipLevelCount, mipLevel =>\n          TexelView.fromTexelsAsColors(\n            format,\n            (coords: Required<GPUOrigin3DDict>): Readonly<PerTexelComponent<number>> => {\n              const size = mipLevelSize[mipLevel];\n              const texelsPerSlice = size[0] * size[1];\n              const texelsPerRow = size[0];\n              const texelId =\n                numTexelsOfPrecedingLevels[mipLevel] +\n                coords.x +\n                coords.y * texelsPerRow +\n                coords.z * texelsPerSlice;\n              const isCandidate = setA.has(texelId);\n              const texel: PerTexelComponent<number> = {};\n              for (const component of rep.componentOrder) {\n                texel[component] = isCandidate ? 1 : 0;\n              }\n              return texel;\n            }\n          )\n        )\n      ),\n      format\n    );\n    if (components.some(c => results[c] !== 0)) {\n      // One or more texels of setA were sampled.\n      if (setA.size === 1) {\n        // We identified a specific texel was sampled.\n        // As there was only one texel in the set, results holds the sampling weights.\n        setA.forEach(texel => sampledTexelWeights.set(texel, results));\n      } else {\n        // More than one texel in the set. Needs splitting.\n        unclassifiedStack.push(setA);\n      }\n    }\n  }\n\n  const getMipLevelFromTexelId = (texelId: number) => {\n    for (let mipLevel = mipLevelCount - 1; mipLevel > 0; --mipLevel) {\n      if (texelId - numTexelsOfPrecedingLevels[mipLevel] >= 0) {\n        return mipLevel;\n      }\n    }\n    return 0;\n  };\n\n  // separate the sampledTexelWeights by mipLevel, then by layer, within a layer the texelId only includes x and y\n  const levels: Map<number, PerTexelComponent<number>>[][] = [];\n  for (const [texelId, weight] of sampledTexelWeights.entries()) {\n    const mipLevel = getMipLevelFromTexelId(texelId);\n    const level = levels[mipLevel] ?? [];\n    levels[mipLevel] = level;\n    const size = mipLevelSize[mipLevel];\n    const texelsPerSlice = size[0] * size[1];\n    const id = texelId - numTexelsOfPrecedingLevels[mipLevel];\n    const layer = Math.floor(id / texelsPerSlice);\n    const layerEntries = level[layer] ?? new Map();\n    level[layer] = layerEntries;\n    const xyId = id - layer * texelsPerSlice;\n    layerEntries.set(xyId, weight);\n  }\n\n  // ┌───┬───┬───┬───┐\n  // │ a │   │   │   │\n  // ├───┼───┼───┼───┤\n  // │   │   │   │   │\n  // ├───┼───┼───┼───┤\n  // │   │   │   │   │\n  // ├───┼───┼───┼───┤\n  // │   │   │   │ b │\n  // └───┴───┴───┴───┘\n  const lines: string[] = [];\n  const letter = (idx: number) => String.fromCodePoint(idx < 30 ? 97 + idx : idx + 9600 - 30); // 97: 'a'\n  let idCount = 0;\n\n  for (let mipLevel = 0; mipLevel < mipLevelCount; ++mipLevel) {\n    const level = levels[mipLevel];\n    if (!level) {\n      continue;\n    }\n\n    const [width, height, depthOrArrayLayers] = mipLevelSize[mipLevel];\n    const texelsPerRow = width;\n\n    for (let layer = 0; layer < depthOrArrayLayers; ++layer) {\n      const layerEntries = level[layer];\n\n      const orderedTexelIndices: number[] = [];\n      lines.push('');\n      const unSampled = layerEntries ? '' : 'un-sampled';\n      lines.push(`layer: ${layer}${isCube ? ` (${kFaceNames[layer]})` : ''} ${unSampled}`);\n\n      if (!layerEntries) {\n        continue;\n      }\n\n      {\n        let line = '  ';\n        for (let x = 0; x < width; x++) {\n          line += `  ${x.toString().padEnd(2)}`;\n        }\n        lines.push(line);\n      }\n      {\n        let line = '  ┌';\n        for (let x = 0; x < width; x++) {\n          line += x === width - 1 ? '───┐' : '───┬';\n        }\n        lines.push(line);\n      }\n      for (let y = 0; y < height; y++) {\n        {\n          let line = `${y.toString().padEnd(2)}│`;\n          for (let x = 0; x < width; x++) {\n            const texelIdx = x + y * texelsPerRow;\n            const weight = layerEntries.get(texelIdx);\n            if (weight !== undefined) {\n              line += ` ${letter(idCount + orderedTexelIndices.length)} │`;\n              orderedTexelIndices.push(texelIdx);\n            } else {\n              line += '   │';\n            }\n          }\n          lines.push(line);\n        }\n        if (y < height - 1) {\n          let line = '  ├';\n          for (let x = 0; x < width; x++) {\n            line += x === width - 1 ? '───┤' : '───┼';\n          }\n          lines.push(line);\n        }\n      }\n      {\n        let line = '  └';\n        for (let x = 0; x < width; x++) {\n          line += x === width - 1 ? '───┘' : '───┴';\n        }\n        lines.push(line);\n      }\n\n      const pad2 = (n: number) => n.toString().padStart(2);\n      const fix5 = (n: number) => n.toFixed(5);\n      orderedTexelIndices.forEach((texelIdx, i) => {\n        const weights = layerEntries.get(texelIdx)!;\n        const y = Math.floor(texelIdx / texelsPerRow);\n        const x = texelIdx % texelsPerRow;\n        const singleWeight = valueIfAllComponentsAreEqual(weights, components);\n        const w =\n          singleWeight !== undefined\n            ? `weight: ${fix5(singleWeight)}`\n            : `weights: [${components.map(c => `${c}: ${fix5(weights[c]!)}`).join(', ')}]`;\n        const coord = `${pad2(x)}, ${pad2(y)}, ${pad2(layer)}`;\n        lines.push(`${letter(idCount + i)}: mip(${mipLevel}) at: [${coord}], ${w}`);\n      });\n      idCount += orderedTexelIndices.length;\n    }\n  }\n\n  return lines;\n}\n\nfunction layoutTwoColumns(columnA: string[], columnB: string[]) {\n  const widthA = Math.max(...columnA.map(l => l.length));\n  const lines = Math.max(columnA.length, columnB.length);\n  const out: string[] = new Array<string>(lines);\n  for (let line = 0; line < lines; line++) {\n    const a = columnA[line] ?? '';\n    const b = columnB[line] ?? '';\n    out[line] = `${a}${' '.repeat(widthA - a.length)} | ${b}`;\n  }\n  return out;\n}\n\n/**\n * Returns the number of layers ot test for a given view dimension\n */\nexport function getDepthOrArrayLayersForViewDimension(viewDimension?: GPUTextureViewDimension) {\n  switch (viewDimension) {\n    case undefined:\n    case '2d':\n      return 1;\n    case '3d':\n      return 8;\n    case 'cube':\n      return 6;\n    default:\n      unreachable();\n  }\n}\n\n/**\n * Choose a texture size based on the given parameters.\n * The size will be in a multiple of blocks. If it's a cube\n * map the size will so be square.\n */\nexport function chooseTextureSize({\n  minSize,\n  minBlocks,\n  format,\n  viewDimension,\n}: {\n  minSize: number;\n  minBlocks: number;\n  format: GPUTextureFormat;\n  viewDimension?: GPUTextureViewDimension;\n}) {\n  const { blockWidth, blockHeight } = kTextureFormatInfo[format];\n  const width = align(Math.max(minSize, blockWidth * minBlocks), blockWidth);\n  const height = align(Math.max(minSize, blockHeight * minBlocks), blockHeight);\n  if (viewDimension === 'cube' || viewDimension === 'cube-array') {\n    const blockLCM = lcm(blockWidth, blockHeight);\n    const largest = Math.max(width, height);\n    const size = align(largest, blockLCM);\n    return [size, size, viewDimension === 'cube-array' ? 24 : 6];\n  }\n  const depthOrArrayLayers = getDepthOrArrayLayersForViewDimension(viewDimension);\n  return [width, height, depthOrArrayLayers];\n}\n\nexport const kSamplePointMethods = ['texel-centre', 'spiral'] as const;\nexport type SamplePointMethods = (typeof kSamplePointMethods)[number];\n\nexport const kCubeSamplePointMethods = ['cube-edges', 'texel-centre', 'spiral'] as const;\nexport type CubeSamplePointMethods = (typeof kSamplePointMethods)[number];\n\ntype TextureBuiltinInputArgs = {\n  textureBuiltin?: TextureBuiltin;\n  descriptor: GPUTextureDescriptor;\n  sampler?: GPUSamplerDescriptor;\n  mipLevel?: RangeDef;\n  sampleIndex?: RangeDef;\n  arrayIndex?: RangeDef;\n  component?: boolean;\n  depthRef?: boolean;\n  offset?: boolean;\n  hashInputs: (number | string | boolean)[];\n};\n\n/**\n * Generates an array of coordinates at which to sample a texture.\n */\nfunction generateTextureBuiltinInputsImpl<T extends Dimensionality>(\n  makeValue: (x: number, y: number, z: number) => T,\n  n: number,\n  args:\n    | (TextureBuiltinInputArgs & {\n        method: 'texel-centre';\n      })\n    | (TextureBuiltinInputArgs & {\n        method: 'spiral';\n        radius?: number;\n        loops?: number;\n      })\n): {\n  coords: T;\n  mipLevel: number;\n  sampleIndex?: number;\n  arrayIndex?: number;\n  offset?: T;\n  component?: number;\n  depthRef?: number;\n}[] {\n  const { method, descriptor } = args;\n  const dimension = descriptor.dimension ?? '2d';\n  const mipLevelCount = descriptor.mipLevelCount ?? 1;\n  const size = virtualMipSize(dimension, descriptor.size, 0);\n  const coords: T[] = [];\n  switch (method) {\n    case 'texel-centre': {\n      for (let i = 0; i < n; i++) {\n        const r = hashU32(i);\n        const x = Math.floor(lerp(0, size[0] - 1, (r & 0xff) / 0xff)) + 0.5;\n        const y = Math.floor(lerp(0, size[1] - 1, ((r >> 8) & 0xff) / 0xff)) + 0.5;\n        const z = Math.floor(lerp(0, size[2] - 1, ((r >> 16) & 0xff) / 0xff)) + 0.5;\n        coords.push(makeValue(x / size[0], y / size[1], z / size[2]));\n      }\n      break;\n    }\n    case 'spiral': {\n      const { radius = 1.5, loops = 2 } = args;\n      for (let i = 0; i < n; i++) {\n        const f = i / (Math.max(n, 2) - 1);\n        const r = radius * f;\n        const a = loops * 2 * Math.PI * f;\n        coords.push(makeValue(0.5 + r * Math.cos(a), 0.5 + r * Math.sin(a), 0));\n      }\n      break;\n    }\n  }\n\n  const _hashInputs = args.hashInputs.map(v =>\n    typeof v === 'string' ? sumOfCharCodesOfString(v) : typeof v === 'boolean' ? (v ? 1 : 0) : v\n  );\n  const makeRangeValue = ({ num, type }: RangeDef, ...hashInputs: number[]) => {\n    const range = num + (type === 'u32' ? 1 : 2);\n    const number =\n      (hashU32(..._hashInputs, ...hashInputs) / 0x1_0000_0000) * range - (type === 'u32' ? 0 : 1);\n    return type === 'f32' ? number : Math.floor(number);\n  };\n  // Generates the same values per coord instead of using all the extra `_hashInputs`.\n  const makeIntHashValueRepeatable = (min: number, max: number, ...hashInputs: number[]) => {\n    const range = max - min;\n    return min + Math.floor((hashU32(...hashInputs) / 0x1_0000_0000) * range);\n  };\n\n  // Samplers across devices use different methods to interpolate.\n  // Quantizing the texture coordinates seems to hit coords that produce\n  // comparable results to our computed results.\n  // Note: This value works with 8x8 textures. Other sizes have not been tested.\n  // Values that worked for reference:\n  // Win 11, NVidia 2070 Super: 16\n  // Linux, AMD Radeon Pro WX 3200: 256\n  // MacOS, M1 Mac: 256\n  const kSubdivisionsPerTexel = 4;\n  const avoidEdgeCase =\n    !args.sampler || args.sampler.minFilter === 'nearest' || isBuiltinGather(args.textureBuiltin);\n  const edgeRemainder = isBuiltinGather(args.textureBuiltin) ? kSubdivisionsPerTexel / 2 : 0;\n  const numComponents = isDepthOrStencilTextureFormat(descriptor.format) ? 1 : 4;\n  return coords.map((c, i) => {\n    const mipLevel = args.mipLevel\n      ? quantizeMipLevel(makeRangeValue(args.mipLevel, i), args.sampler?.mipmapFilter ?? 'nearest')\n      : 0;\n    const clampedMipLevel = clamp(mipLevel, { min: 0, max: mipLevelCount - 1 });\n    const mipSize = virtualMipSize(dimension, size, clampedMipLevel);\n    const q = mipSize.map(v => v * kSubdivisionsPerTexel);\n\n    const coords = c.map((v, i) => {\n      // Quantize to kSubdivisionsPerPixel\n      const v1 = Math.floor(v * q[i]);\n      // If it's nearest or textureGather and we're on the edge of a texel then move us off the edge\n      // since the edge could choose one texel or another.\n      const isEdgeCase = Math.abs(v1 % kSubdivisionsPerTexel) === edgeRemainder;\n      const v2 = isEdgeCase && avoidEdgeCase ? v1 + 1 : v1;\n      // Convert back to texture coords\n      return v2 / q[i];\n    }) as T;\n\n    return {\n      coords,\n      mipLevel,\n      sampleIndex: args.sampleIndex ? makeRangeValue(args.sampleIndex, i, 1) : undefined,\n      arrayIndex: args.arrayIndex ? makeRangeValue(args.arrayIndex, i, 2) : undefined,\n      depthRef: args.depthRef ? makeRangeValue({ num: 1, type: 'f32' }, i, 5) : undefined,\n      offset: args.offset\n        ? (coords.map((_, j) => makeIntHashValueRepeatable(-8, 8, i, 3 + j)) as T)\n        : undefined,\n      component: args.component ? makeIntHashValueRepeatable(0, numComponents, i, 4) : undefined,\n    };\n  });\n}\n\n/**\n * When mipmapFilter === 'nearest' we need to stay away from 0.5\n * because the GPU could decide to choose one mip or the other.\n *\n * Some example transition values, the value at which the GPU chooses\n * mip level 1 over mip level 0:\n *\n * M1 Mac: 0.515381\n * Intel Mac: 0.49999\n * AMD Mac: 0.5\n */\nconst kMipEpsilon = 0.02;\nfunction quantizeMipLevel(mipLevel: number, mipmapFilter: GPUMipmapFilterMode) {\n  if (mipmapFilter === 'linear') {\n    return mipLevel;\n  }\n  const intMip = Math.floor(mipLevel);\n  const fractionalMip = mipLevel - intMip;\n  if (fractionalMip < 0.5 - kMipEpsilon || fractionalMip > 0.5 + kMipEpsilon) {\n    return mipLevel;\n  } else {\n    return intMip + 0.5 + (fractionalMip < 0.5 ? -kMipEpsilon : +kMipEpsilon);\n  }\n}\n\n// Removes the first element from an array of types\ntype FilterFirstElement<T extends unknown[]> = T extends [unknown, ...infer R] ? R : [];\n\ntype GenerateTextureBuiltinInputsImplArgs = FilterFirstElement<\n  Parameters<typeof generateTextureBuiltinInputsImpl>\n>;\n\nexport function generateTextureBuiltinInputs1D(...args: GenerateTextureBuiltinInputsImplArgs) {\n  return generateTextureBuiltinInputsImpl<vec1>((x: number) => [x], ...args);\n}\n\nexport function generateTextureBuiltinInputs2D(...args: GenerateTextureBuiltinInputsImplArgs) {\n  return generateTextureBuiltinInputsImpl<vec2>((x: number, y: number) => [x, y], ...args);\n}\n\nexport function generateTextureBuiltinInputs3D(...args: GenerateTextureBuiltinInputsImplArgs) {\n  return generateTextureBuiltinInputsImpl<vec3>(\n    (x: number, y: number, z: number) => [x, y, z],\n    ...args\n  );\n}\n\ntype mat3 =\n  /* prettier-ignore */ [\n  number, number, number,\n  number, number, number,\n  number, number, number,\n];\n\nconst kFaceUVMatrices: mat3[] =\n  /* prettier-ignore */ [\n  [ 0,  0,  -2,  0, -2,   0,  1,  1,   1],   // pos-x\n  [ 0,  0,   2,  0, -2,   0, -1,  1,  -1],   // neg-x\n  [ 2,  0,   0,  0,  0,   2, -1,  1,  -1],   // pos-y\n  [ 2,  0,   0,  0,  0,  -2, -1, -1,   1],   // neg-y\n  [ 2,  0,   0,  0, -2,   0, -1,  1,   1],   // pos-z\n  [-2,  0,   0,  0, -2,   0,  1,  1,  -1],   // neg-z\n];\n\n/** multiply a vec3 by mat3 */\nfunction transformMat3(v: vec3, m: mat3): vec3 {\n  const x = v[0];\n  const y = v[1];\n  const z = v[2];\n\n  return [\n    x * m[0] + y * m[3] + z * m[6],\n    x * m[1] + y * m[4] + z * m[7],\n    x * m[2] + y * m[5] + z * m[8],\n  ];\n}\n\n/** normalize a vec3 */\nfunction normalize(v: vec3): vec3 {\n  const length = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);\n  assert(length > 0);\n  return v.map(v => v / length) as vec3;\n}\n\n/**\n * Converts a cube map coordinate to a uv coordinate (0 to 1) and layer (0.5/6.0 to 5.5/6.0).\n */\nexport function convertCubeCoordToNormalized3DTextureCoord(v: vec3): vec3 {\n  let uvw;\n  let layer;\n  // normalize the coord.\n  // MAINTENANCE_TODO: handle(0, 0, 0)\n  const r = normalize(v);\n  const absR = r.map(v => Math.abs(v));\n  if (absR[0] > absR[1] && absR[0] > absR[2]) {\n    // x major\n    const negX = r[0] < 0.0 ? 1 : 0;\n    uvw = [negX ? r[2] : -r[2], -r[1], absR[0]];\n    layer = negX;\n  } else if (absR[1] > absR[2]) {\n    // y major\n    const negY = r[1] < 0.0 ? 1 : 0;\n    uvw = [r[0], negY ? -r[2] : r[2], absR[1]];\n    layer = 2 + negY;\n  } else {\n    // z major\n    const negZ = r[2] < 0.0 ? 1 : 0;\n    uvw = [negZ ? -r[0] : r[0], -r[1], absR[2]];\n    layer = 4 + negZ;\n  }\n  return [(uvw[0] / uvw[2] + 1) * 0.5, (uvw[1] / uvw[2] + 1) * 0.5, (layer + 0.5) / 6];\n}\n\n/**\n * Convert a 3d texcoord into a cube map coordinate.\n */\nexport function convertNormalized3DTexCoordToCubeCoord(uvLayer: vec3) {\n  const [u, v, faceLayer] = uvLayer;\n  return normalize(transformMat3([u, v, 1], kFaceUVMatrices[Math.min(5, faceLayer * 6) | 0]));\n}\n\n/**\n * Wrap a texel based face coord across cube faces\n *\n * We have a face texture in texels coord where U/V choose a texel and W chooses the face.\n * If U/V are outside the size of the texture then, when normalized and converted\n * to a cube map coordinate, they'll end up pointing to a different face.\n *\n * addressMode is effectively ignored for cube\n *\n * By converting from a texel based coord to a normalized coord and then to a cube map coord,\n * if the texel was outside of the face, the cube map coord will end up pointing to a different\n * face. We then convert back cube coord -> normalized face coord -> texel based coord\n */\nfunction wrapFaceCoordToCubeFaceAtEdgeBoundaries(textureSize: number, faceCoord: vec3) {\n  // convert texel based face coord to normalized 2d-array coord\n  const nc0: vec3 = [\n    (faceCoord[0] + 0.5) / textureSize,\n    (faceCoord[1] + 0.5) / textureSize,\n    (faceCoord[2] + 0.5) / 6,\n  ];\n  const cc = convertNormalized3DTexCoordToCubeCoord(nc0);\n  const nc1 = convertCubeCoordToNormalized3DTextureCoord(cc);\n  // convert normalized 2d-array coord back texel based face coord\n  const fc = [\n    Math.floor(nc1[0] * textureSize),\n    Math.floor(nc1[1] * textureSize),\n    Math.floor(nc1[2] * 6),\n  ];\n\n  return fc;\n}\n\nfunction applyAddressModesToCoords(\n  addressMode: GPUAddressMode[],\n  textureSize: number[],\n  coord: number[]\n) {\n  return coord.map((v, i) => {\n    switch (addressMode[i]) {\n      case 'clamp-to-edge':\n        return clamp(v, { min: 0, max: textureSize[i] - 1 });\n      case 'mirror-repeat': {\n        const n = Math.floor(v / textureSize[i]);\n        v = v - n * textureSize[i];\n        return (n & 1) !== 0 ? textureSize[i] - v - 1 : v;\n      }\n      case 'repeat':\n        return v - Math.floor(v / textureSize[i]) * textureSize[i];\n      default:\n        unreachable();\n    }\n  });\n}\n\n/**\n * Generates an array of coordinates at which to sample a texture for a cubemap\n */\nexport function generateSamplePointsCube(\n  n: number,\n  args:\n    | (TextureBuiltinInputArgs & {\n        method: 'texel-centre';\n      })\n    | (TextureBuiltinInputArgs & {\n        method: 'spiral';\n        radius?: number;\n        loops?: number;\n      })\n    | (TextureBuiltinInputArgs & {\n        method: 'cube-edges';\n      })\n): {\n  coords: vec3;\n  mipLevel: number;\n  arrayIndex?: number;\n  offset?: undefined;\n  component?: number;\n  depthRef?: number;\n}[] {\n  const { method, descriptor } = args;\n  const mipLevelCount = descriptor.mipLevelCount ?? 1;\n  const size = virtualMipSize('2d', descriptor.size, 0);\n  const textureWidth = size[0];\n  const coords: vec3[] = [];\n  switch (method) {\n    case 'texel-centre': {\n      for (let i = 0; i < n; i++) {\n        const r = hashU32(i);\n        const u = (Math.floor(lerp(0, textureWidth - 1, (r & 0xff) / 0xff)) + 0.5) / textureWidth;\n        const v =\n          (Math.floor(lerp(0, textureWidth - 1, ((r >> 8) & 0xff) / 0xff)) + 0.5) / textureWidth;\n        const face = Math.floor(lerp(0, 6, ((r >> 16) & 0xff) / 0x100));\n        coords.push(convertNormalized3DTexCoordToCubeCoord([u, v, face]));\n      }\n      break;\n    }\n    case 'spiral': {\n      const { radius = 1.5, loops = 2 } = args;\n      for (let i = 0; i < n; i++) {\n        const f = (i + 1) / (Math.max(n, 2) - 1);\n        const r = radius * f;\n        const theta = loops * 2 * Math.PI * f;\n        const phi = loops * 1.3 * Math.PI * f;\n        const sinTheta = Math.sin(theta);\n        const cosTheta = Math.cos(theta);\n        const sinPhi = Math.sin(phi);\n        const cosPhi = Math.cos(phi);\n        const ux = cosTheta * sinPhi;\n        const uy = cosPhi;\n        const uz = sinTheta * sinPhi;\n        coords.push([ux * r, uy * r, uz * r]);\n      }\n      break;\n    }\n    case 'cube-edges': {\n      /* prettier-ignore */\n      coords.push(\n        // between edges\n        // +x\n        [  1   , -1.01,  0    ],  // wrap -y\n        [  1   , +1.01,  0    ],  // wrap +y\n        [  1   ,  0   , -1.01 ],  // wrap -z\n        [  1   ,  0   , +1.01 ],  // wrap +z\n        // -x\n        [ -1   , -1.01,  0    ],  // wrap -y\n        [ -1   , +1.01,  0    ],  // wrap +y\n        [ -1   ,  0   , -1.01 ],  // wrap -z\n        [ -1   ,  0   , +1.01 ],  // wrap +z\n\n        // +y\n        [ -1.01,  1   ,  0    ],  // wrap -x\n        [ +1.01,  1   ,  0    ],  // wrap +x\n        [  0   ,  1   , -1.01 ],  // wrap -z\n        [  0   ,  1   , +1.01 ],  // wrap +z\n        // -y\n        [ -1.01, -1   ,  0    ],  // wrap -x\n        [ +1.01, -1   ,  0    ],  // wrap +x\n        [  0   , -1   , -1.01 ],  // wrap -z\n        [  0   , -1   , +1.01 ],  // wrap +z\n\n        // +z\n        [ -1.01,  0   ,  1    ],  // wrap -x\n        [ +1.01,  0   ,  1    ],  // wrap +x\n        [  0   , -1.01,  1    ],  // wrap -y\n        [  0   , +1.01,  1    ],  // wrap +y\n        // -z\n        [ -1.01,  0   , -1    ],  // wrap -x\n        [ +1.01,  0   , -1    ],  // wrap +x\n        [  0   , -1.01, -1    ],  // wrap -y\n        [  0   , +1.01, -1    ],  // wrap +y\n\n        // corners (see comment \"Issues with corners of cubemaps\")\n        // for why these are commented out.\n        // [-1.01, -1.02, -1.03],\n        // [ 1.01, -1.02, -1.03],\n        // [-1.01,  1.02, -1.03],\n        // [ 1.01,  1.02, -1.03],\n        // [-1.01, -1.02,  1.03],\n        // [ 1.01, -1.02,  1.03],\n        // [-1.01,  1.02,  1.03],\n        // [ 1.01,  1.02,  1.03],\n      );\n      break;\n    }\n  }\n\n  const _hashInputs = args.hashInputs.map(v =>\n    typeof v === 'string' ? sumOfCharCodesOfString(v) : typeof v === 'boolean' ? (v ? 1 : 0) : v\n  );\n  const makeRangeValue = ({ num, type }: RangeDef, ...hashInputs: number[]) => {\n    const range = num + (type === 'u32' ? 1 : 2);\n    const number =\n      (hashU32(..._hashInputs, ...hashInputs) / 0x1_0000_0000) * range - (type === 'u32' ? 0 : 1);\n    return type === 'f32' ? number : Math.floor(number);\n  };\n  const makeIntHashValue = (min: number, max: number, ...hashInputs: number[]) => {\n    const range = max - min;\n    return min + Math.floor((hashU32(..._hashInputs, ...hashInputs) / 0x1_0000_0000) * range);\n  };\n\n  // Samplers across devices use different methods to interpolate.\n  // Quantizing the texture coordinates seems to hit coords that produce\n  // comparable results to our computed results.\n  // Note: This value works with 8x8 textures. Other sizes have not been tested.\n  // Values that worked for reference:\n  // Win 11, NVidia 2070 Super: 16\n  // Linux, AMD Radeon Pro WX 3200: 256\n  // MacOS, M1 Mac: 256\n  //\n  // Note: When doing `textureGather...` we can't use texel centers\n  // because which 4 pixels will be gathered jumps if we're slightly under\n  // or slightly over the center\n  //\n  // Similarly, if we're using 'nearest' filtering then we don't want texel\n  // edges for the same reason.\n  //\n  // Also note that for textureGather. The way it works for cube maps is to\n  // first convert from cube map coordinate to a 2D texture coordinate and\n  // a face. Then, choose 4 texels just like normal 2D texture coordinates.\n  // If one of the 4 texels is outside the current face, wrap it to the correct\n  // face.\n  //\n  // An issue this brings up though. Imagine a 2D texture with addressMode = 'repeat'\n  //\n  //       2d texture   (same texture repeated to show 'repeat')\n  //     ┌───┬───┬───┐     ┌───┬───┬───┐\n  //     │   │   │   │     │   │   │   │\n  //     ├───┼───┼───┤     ├───┼───┼───┤\n  //     │   │   │  a│     │c  │   │   │\n  //     ├───┼───┼───┤     ├───┼───┼───┤\n  //     │   │   │  b│     │d  │   │   │\n  //     └───┴───┴───┘     └───┴───┴───┘\n  //\n  // Assume the texture coordinate is at the bottom right corner of a.\n  // Then textureGather will grab c, d, b, a (no idea why that order).\n  // but think of it as top-right, bottom-right, bottom-left, top-left.\n  // Similarly, if the texture coordinate is at the top left of d it\n  // will select the same 4 texels.\n  //\n  // But, in the case of a cubemap, each face is in different direction\n  // relative to the face next to it.\n  //\n  //             +-----------+\n  //             |0->u       |\n  //             |↓          |\n  //             |v   +y     |\n  //             |    (2)    |\n  //             |           |\n  // +-----------+-----------+-----------+-----------+\n  // |0->u       |0->u       |0->u       |0->u       |\n  // |↓          |↓          |↓          |↓          |\n  // |v   -x     |v   +z     |v   +x     |v   -z     |\n  // |    (1)    |    (4)    |    (0)    |    (5)    |\n  // |           |           |           |           |\n  // +-----------+-----------+-----------+-----------+\n  //             |0->u       |\n  //             |↓          |\n  //             |v   -y     |\n  //             |    (3)    |\n  //             |           |\n  //             +-----------+\n  //\n  // As an example, imagine going from the +y to the +x face.\n  // See diagram above, the right edge of the +y face wraps\n  // to the top edge of the +x face.\n  //\n  //                             +---+---+\n  //                             |  a|c  |\n  //     ┌───┬───┬───┐           ┌───┬───┬───┐\n  //     │   │   │   │           │  b│d  │   │\n  //     ├───┼───┼───┤---+       ├───┼───┼───┤\n  //     │   │   │  a│ c |       │   │   │   │\n  //     ├───┼───┼───┤---+       ├───┼───┼───┤\n  //     │   │   │  b│ d |       │   │   │   │\n  //     └───┴───┴───┘---+       └───┴───┴───┘\n  //        +y face                 +x face\n  //\n  // If the texture coordinate is in the bottom right corner of a,\n  // the rectangle of texels we read are a,b,c,d and, if we the\n  // texture coordinate is in the top left corner of d we also\n  // read a,b,c,d according to the 2 diagrams above.\n  //\n  // But, notice that when reading from the POV of +y vs +x,\n  // which actual a,b,c,d texels are different.\n  //\n  // From the POV of face +x: a,b are in face +x and c,d are in face +y\n  // From the POV of face +y: a,c are in face +x and b,d are in face +y\n  //\n  // This is all the long way of saying that if we're on the edge of a cube\n  // face we could get drastically different results because the orientation\n  // of the rectangle of the 4 texels we use, rotates. So, we need to avoid\n  // any values too close to the edge just in case our math is different than\n  // the GPU's.\n  //\n  const kSubdivisionsPerTexel = 4;\n  const avoidEdgeCase =\n    !args.sampler || args.sampler.minFilter === 'nearest' || isBuiltinGather(args.textureBuiltin);\n  const edgeRemainder = isBuiltinGather(args.textureBuiltin) ? kSubdivisionsPerTexel / 2 : 0;\n  return coords.map((c, i) => {\n    const mipLevel = args.mipLevel\n      ? quantizeMipLevel(makeRangeValue(args.mipLevel, i), args.sampler?.mipmapFilter ?? 'nearest')\n      : 0;\n    const clampedMipLevel = clamp(mipLevel, { min: 0, max: mipLevelCount - 1 });\n    const mipSize = virtualMipSize('2d', size, Math.ceil(clampedMipLevel));\n    const q = [\n      mipSize[0] * kSubdivisionsPerTexel,\n      mipSize[0] * kSubdivisionsPerTexel,\n      6 * kSubdivisionsPerTexel,\n    ];\n\n    const uvw = convertCubeCoordToNormalized3DTextureCoord(c);\n\n    // If this is a corner, move to in so it's not\n    // (see comment \"Issues with corners of cubemaps\")\n    const ndx = getUnusedCubeCornerSampleIndex(mipSize[0], uvw);\n    if (ndx >= 0) {\n      const halfTexel = 0.5 / mipSize[0];\n      uvw[0] = clamp(uvw[0], { min: halfTexel, max: 1 - halfTexel });\n    }\n\n    const quantizedUVW = uvw.map((v, i) => {\n      // Quantize to kSubdivisionsPerPixel\n      const v1 = Math.floor(v * q[i]);\n      // If it's nearest or textureGather and we're on the edge of a texel then move us off the edge\n      // since the edge could choose one texel or another.\n      const isEdgeCase = Math.abs(v1 % kSubdivisionsPerTexel) === edgeRemainder;\n      const v2 = isEdgeCase && avoidEdgeCase ? v1 + 1 : v1;\n      // Convert back to texture coords slightly off\n      return (v2 + 1 / 16) / q[i];\n    }) as vec3;\n\n    const coords = convertNormalized3DTexCoordToCubeCoord(quantizedUVW);\n    return {\n      coords,\n      mipLevel,\n      arrayIndex: args.arrayIndex ? makeRangeValue(args.arrayIndex, i, 2) : undefined,\n      depthRef: args.depthRef ? makeRangeValue({ num: 1, type: 'f32' }, i, 5) : undefined,\n      component: args.component ? makeIntHashValue(0, 4, i, 4) : undefined,\n    };\n  });\n}\n\nfunction wgslTypeFor(data: number | Dimensionality, type: 'f' | 'i' | 'u'): string {\n  if (Array.isArray(data)) {\n    switch (data.length) {\n      case 1:\n        return `${type}32`;\n      case 2:\n        return `vec2${type}`;\n      case 3:\n        return `vec3${type}`;\n      default:\n        unreachable();\n    }\n  }\n  return `${type}32`;\n}\n\nfunction wgslExpr(data: number | vec1 | vec2 | vec3 | vec4): string {\n  if (Array.isArray(data)) {\n    switch (data.length) {\n      case 1:\n        return data[0].toString();\n      case 2:\n        return `vec2(${data.map(v => v.toString()).join(', ')})`;\n      case 3:\n        return `vec3(${data.map(v => v.toString()).join(', ')})`;\n      default:\n        unreachable();\n    }\n  }\n  return data.toString();\n}\n\nfunction wgslExprFor(data: number | vec1 | vec2 | vec3 | vec4, type: 'f' | 'i' | 'u'): string {\n  if (Array.isArray(data)) {\n    switch (data.length) {\n      case 1:\n        return `${type}(${data[0].toString()})`;\n      case 2:\n        return `vec2${type}(${data.map(v => v.toString()).join(', ')})`;\n      case 3:\n        return `vec3${type}(${data.map(v => v.toString()).join(', ')})`;\n      default:\n        unreachable();\n    }\n  }\n  return `${type}32(${data.toString()})`;\n}\n\nfunction binKey<T extends Dimensionality>(call: TextureCall<T>): string {\n  const keys: string[] = [];\n  for (const name of kTextureCallArgNames) {\n    const value = call[name];\n    if (value !== undefined) {\n      if (name === 'offset' || name === 'component') {\n        // offset and component must be constant expressions\n        keys.push(`${name}: ${wgslExpr(value)}`);\n      } else {\n        keys.push(`${name}: ${wgslTypeFor(value, call.coordType)}`);\n      }\n    }\n  }\n  return `${call.builtin}(${keys.join(', ')})`;\n}\n\nfunction buildBinnedCalls<T extends Dimensionality>(calls: TextureCall<T>[]) {\n  const args: string[] = [];\n  const fields: string[] = [];\n  const data: number[] = [];\n  const prototype = calls[0];\n\n  if (isBuiltinGather(prototype.builtin) && prototype['componentType']) {\n    args.push(`/* component */ ${wgslExpr(prototype['component']!)}`);\n  }\n\n  // All texture builtins take a Texture\n  args.push('T');\n\n  if (builtinNeedsSampler(prototype.builtin)) {\n    // textureSample*() builtins take a sampler as the second argument\n    args.push('S');\n  }\n\n  for (const name of kTextureCallArgNames) {\n    const value = prototype[name];\n    if (value !== undefined) {\n      if (name === 'offset') {\n        args.push(`/* offset */ ${wgslExpr(value)}`);\n      } else if (name === 'component') {\n        // was handled above\n      } else {\n        const type =\n          name === 'mipLevel'\n            ? prototype.levelType!\n            : name === 'arrayIndex'\n            ? prototype.arrayIndexType!\n            : name === 'sampleIndex'\n            ? prototype.sampleIndexType!\n            : name === 'depthRef'\n            ? 'f'\n            : prototype.coordType;\n        args.push(`args.${name}`);\n        fields.push(`@align(16) ${name} : ${wgslTypeFor(value, type)}`);\n      }\n    }\n  }\n\n  for (const call of calls) {\n    for (const name of kTextureCallArgNames) {\n      const value = call[name];\n      assert(\n        (prototype[name] === undefined) === (value === undefined),\n        'texture calls are not binned correctly'\n      );\n      if (value !== undefined && name !== 'offset' && name !== 'component') {\n        const type = getCallArgType<T>(call, name);\n        const bitcastToU32 = kBitCastFunctions[type];\n        if (value instanceof Array) {\n          for (const c of value) {\n            data.push(bitcastToU32(c));\n          }\n        } else {\n          data.push(bitcastToU32(value));\n        }\n        // All fields are aligned to 16 bytes.\n        while ((data.length & 3) !== 0) {\n          data.push(0);\n        }\n      }\n    }\n  }\n\n  const expr = `${prototype.builtin}(${args.join(', ')})`;\n\n  return { expr, fields, data };\n}\n\nfunction binCalls<T extends Dimensionality>(calls: TextureCall<T>[]): number[][] {\n  const map = new Map<string, number>(); // key to bin index\n  const bins: number[][] = [];\n  calls.forEach((call, callIdx) => {\n    const key = binKey(call);\n    const binIdx = map.get(key);\n    if (binIdx === undefined) {\n      map.set(key, bins.length);\n      bins.push([callIdx]);\n    } else {\n      bins[binIdx].push(callIdx);\n    }\n  });\n  return bins;\n}\n\nexport function describeTextureCall<T extends Dimensionality>(call: TextureCall<T>): string {\n  const args: string[] = [];\n  if (isBuiltinGather(call.builtin) && call.componentType) {\n    args.push(`component: ${wgslExprFor(call.component!, call.componentType)}`);\n  }\n  args.push('texture: T');\n  if (builtinNeedsSampler(call.builtin)) {\n    args.push('sampler: S');\n  }\n  for (const name of kTextureCallArgNames) {\n    const value = call[name];\n    if (value !== undefined && name !== 'component') {\n      if (name === 'coords') {\n        args.push(`${name}: ${wgslExprFor(value, call.coordType)}`);\n      } else if (name === 'mipLevel') {\n        args.push(`${name}: ${wgslExprFor(value, call.levelType!)}`);\n      } else if (name === 'arrayIndex') {\n        args.push(`${name}: ${wgslExprFor(value, call.arrayIndexType!)}`);\n      } else if (name === 'sampleIndex') {\n        args.push(`${name}: ${wgslExprFor(value, call.sampleIndexType!)}`);\n      } else if (name === 'depthRef') {\n        args.push(`${name}: ${wgslExprFor(value, 'f')}`);\n      } else {\n        args.push(`${name}: ${wgslExpr(value)}`);\n      }\n    }\n  }\n  return `${call.builtin}(${args.join(', ')})`;\n}\n\nconst s_deviceToPipelines = new WeakMap<GPUDevice, Map<string, GPURenderPipeline>>();\n\n/**\n * Given a list of \"calls\", each one of which has a texture coordinate,\n * generates a fragment shader that uses the fragment position as an index\n * (position.y * 256 + position.x) That index is then used to look up a\n * coordinate from a storage buffer which is used to call the WGSL texture\n * function to read/sample the texture, and then write to an rgba32float\n * texture.  We then read the rgba32float texture for the per \"call\" results.\n *\n * Calls are \"binned\" by call parameters. Each bin has its own structure and\n * field in the storage buffer. This allows the calls to be non-homogenous and\n * each have their own data type for coordinates.\n */\nexport async function doTextureCalls<T extends Dimensionality>(\n  t: GPUTest,\n  gpuTexture: GPUTexture | GPUExternalTexture,\n  viewDescriptor: GPUTextureViewDescriptor,\n  textureType: string,\n  sampler: GPUSamplerDescriptor | undefined,\n  calls: TextureCall<T>[]\n) {\n  const {\n    format,\n    dimension,\n    depthOrArrayLayers,\n    sampleCount,\n  }: {\n    format: GPUTextureFormat;\n    dimension: GPUTextureDimension;\n    depthOrArrayLayers: number;\n    sampleCount: number;\n  } =\n    gpuTexture instanceof GPUExternalTexture\n      ? { format: 'rgba8unorm', dimension: '2d', depthOrArrayLayers: 1, sampleCount: 1 }\n      : gpuTexture;\n\n  let structs = '';\n  let body = '';\n  let dataFields = '';\n  const data: number[] = [];\n  let callCount = 0;\n  const binned = binCalls(calls);\n  binned.forEach((binCalls, binIdx) => {\n    const b = buildBinnedCalls(binCalls.map(callIdx => calls[callIdx]));\n    structs += `struct Args${binIdx} {\n  ${b.fields.join(',  \\n')}\n}\n`;\n    dataFields += `  args${binIdx} : array<Args${binIdx}, ${binCalls.length}>,\n`;\n    body += `\n  {\n    let is_active = (frag_idx >= ${callCount}) & (frag_idx < ${callCount + binCalls.length});\n    let args = data.args${binIdx}[frag_idx - ${callCount}];\n    let call = ${b.expr};\n    result = select(result, call, is_active);\n  }\n`;\n    callCount += binCalls.length;\n    data.push(...b.data);\n  });\n\n  const dataBuffer = t.createBufferTracked({\n    size: data.length * 4,\n    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\n  });\n  t.device.queue.writeBuffer(dataBuffer, 0, new Uint32Array(data));\n\n  const builtin = calls[0].builtin;\n  const isCompare = isBuiltinComparison(builtin);\n\n  const { resultType, resultFormat, componentType } = isBuiltinGather(builtin)\n    ? getTextureFormatTypeInfo(format)\n    : gpuTexture instanceof GPUExternalTexture\n    ? ({ resultType: 'vec4f', resultFormat: 'rgba32float', componentType: 'f32' } as const)\n    : textureType.includes('depth')\n    ? ({ resultType: 'f32', resultFormat: 'rgba32float', componentType: 'f32' } as const)\n    : getTextureFormatTypeInfo(format);\n  const returnType = `vec4<${componentType}>`;\n\n  const samplerType = isCompare ? 'sampler_comparison' : 'sampler';\n\n  const rtWidth = 256;\n  const renderTarget = t.createTextureTracked({\n    format: resultFormat,\n    size: { width: rtWidth, height: Math.ceil(calls.length / rtWidth) },\n    usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n  });\n\n  const code = `\n${structs}\n\nstruct Data {\n${dataFields}\n}\n\n@vertex\nfn vs_main(@builtin(vertex_index) vertex_index : u32) -> @builtin(position) vec4f {\n  let positions = array(\n    vec4f(-1,  1, 0, 1), vec4f( 1,  1, 0, 1),\n    vec4f(-1, -1, 0, 1), vec4f( 1, -1, 0, 1),\n  );\n  return positions[vertex_index];\n}\n\n@group(0) @binding(0) var          T    : ${textureType};\n${sampler ? `@group(0) @binding(1) var          S    : ${samplerType}` : ''};\n@group(0) @binding(2) var<storage> data : Data;\n\n@fragment\nfn fs_main(@builtin(position) frag_pos : vec4f) -> @location(0) ${returnType} {\n  let frag_idx = u32(frag_pos.x) + u32(frag_pos.y) * ${renderTarget.width};\n  var result : ${resultType};\n${body}\n  return ${returnType}(result);\n}\n`;\n\n  const pipelines = s_deviceToPipelines.get(t.device) ?? new Map<string, GPURenderPipeline>();\n  s_deviceToPipelines.set(t.device, pipelines);\n\n  // unfilterable-float textures can only be used with manually created bindGroupLayouts\n  // since the default 'auto' layout requires filterable textures/samplers.\n  // So, if we don't need filtering, don't request a filtering sampler. If we require\n  // filtering then check if the format is 32float format and if float32-filterable\n  // is enabled.\n  const info = kTextureFormatInfo[format ?? 'rgba8unorm'];\n  const isFiltering =\n    !!sampler &&\n    (sampler.minFilter === 'linear' ||\n      sampler.magFilter === 'linear' ||\n      sampler.mipmapFilter === 'linear');\n  let sampleType: GPUTextureSampleType = textureType.startsWith('texture_depth')\n    ? 'depth'\n    : isDepthTextureFormat(format)\n    ? 'unfilterable-float'\n    : isStencilTextureFormat(format)\n    ? 'uint'\n    : info.color?.type ?? 'float';\n  if (isFiltering && sampleType === 'unfilterable-float') {\n    assert(is32Float(format));\n    assert(t.device.features.has('float32-filterable'));\n    sampleType = 'float';\n  }\n  if (sampleCount > 1 && sampleType === 'float') {\n    sampleType = 'unfilterable-float';\n  }\n\n  const entries: GPUBindGroupLayoutEntry[] = [\n    {\n      binding: 2,\n      visibility: GPUShaderStage.FRAGMENT,\n      buffer: {\n        type: 'read-only-storage',\n      },\n    },\n  ];\n\n  const viewDimension = effectiveViewDimensionForDimension(\n    viewDescriptor.dimension,\n    dimension,\n    depthOrArrayLayers\n  );\n\n  if (textureType.includes('storage')) {\n    entries.push({\n      binding: 0,\n      visibility: GPUShaderStage.FRAGMENT,\n      storageTexture: {\n        access: 'read-only',\n        viewDimension,\n        format,\n      },\n    });\n  } else if (gpuTexture instanceof GPUExternalTexture) {\n    entries.push({\n      binding: 0,\n      visibility: GPUShaderStage.FRAGMENT,\n      externalTexture: {},\n    });\n  } else {\n    entries.push({\n      binding: 0,\n      visibility: GPUShaderStage.FRAGMENT,\n      texture: {\n        sampleType,\n        viewDimension,\n        multisampled: sampleCount > 1,\n      },\n    });\n  }\n\n  if (sampler) {\n    entries.push({\n      binding: 1,\n      visibility: GPUShaderStage.FRAGMENT,\n      sampler: {\n        type: isCompare ? 'comparison' : isFiltering ? 'filtering' : 'non-filtering',\n      },\n    });\n  }\n\n  const id = `${renderTarget.format}:${JSON.stringify(entries)}:${code}`;\n  let pipeline = pipelines.get(id);\n  if (!pipeline) {\n    const shaderModule = t.device.createShaderModule({ code });\n    const bindGroupLayout = t.device.createBindGroupLayout({ entries });\n    const layout = t.device.createPipelineLayout({\n      bindGroupLayouts: [bindGroupLayout],\n    });\n\n    pipeline = await t.device.createRenderPipelineAsync({\n      layout,\n      vertex: { module: shaderModule },\n      fragment: {\n        module: shaderModule,\n        targets: [{ format: renderTarget.format }],\n      },\n      primitive: { topology: 'triangle-strip' },\n    });\n\n    pipelines.set(id, pipeline);\n  }\n\n  const gpuSampler = sampler ? t.device.createSampler(sampler) : undefined;\n\n  const bindGroup = t.device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: [\n      {\n        binding: 0,\n        resource:\n          gpuTexture instanceof GPUExternalTexture\n            ? gpuTexture\n            : gpuTexture.createView(viewDescriptor),\n      },\n      ...(sampler ? [{ binding: 1, resource: gpuSampler! }] : []),\n      { binding: 2, resource: { buffer: dataBuffer } },\n    ],\n  });\n\n  const bytesPerRow = align(16 * renderTarget.width, 256);\n  const resultBuffer = t.createBufferTracked({\n    size: renderTarget.height * bytesPerRow,\n    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n  });\n  const encoder = t.device.createCommandEncoder();\n\n  const renderPass = encoder.beginRenderPass({\n    colorAttachments: [\n      {\n        view: renderTarget.createView(),\n        loadOp: 'clear',\n        storeOp: 'store',\n      },\n    ],\n  });\n\n  renderPass.setPipeline(pipeline);\n  renderPass.setBindGroup(0, bindGroup);\n  renderPass.draw(4);\n  renderPass.end();\n  encoder.copyTextureToBuffer(\n    { texture: renderTarget },\n    { buffer: resultBuffer, bytesPerRow },\n    { width: renderTarget.width, height: renderTarget.height }\n  );\n  t.device.queue.submit([encoder.finish()]);\n\n  await resultBuffer.mapAsync(GPUMapMode.READ);\n\n  const view = TexelView.fromTextureDataByReference(\n    renderTarget.format as EncodableTextureFormat,\n    new Uint8Array(resultBuffer.getMappedRange()),\n    {\n      bytesPerRow,\n      rowsPerImage: renderTarget.height,\n      subrectOrigin: [0, 0, 0],\n      subrectSize: [renderTarget.width, renderTarget.height],\n    }\n  );\n\n  let outIdx = 0;\n  const out = new Array<PerTexelComponent<number>>(calls.length);\n  for (const bin of binned) {\n    for (const callIdx of bin) {\n      const x = outIdx % rtWidth;\n      const y = Math.floor(outIdx / rtWidth);\n      out[callIdx] = view.color({ x, y, z: 0 });\n      outIdx++;\n    }\n  }\n\n  renderTarget.destroy();\n  resultBuffer.destroy();\n\n  return out;\n}\n"],"mappings":"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AGue,MAAM,GAAG1Y,IAAI,CAACQ,KAAK,CAACkY,MAAM,CAAC;EACrD,CAAC;EACD,MAAMkD,gBAAgB,GAAGA,CAACzZ,GAAW,EAAEC,GAAW,EAAE,GAAGoW,UAAoB,KAAK;IAC9E,MAAM/gB,KAAK,GAAG2K,GAAG,GAAGD,GAAG;IACvB,OAAOA,GAAG,GAAGnC,IAAI,CAACQ,KAAK,CAAElI,OAAO,CAAC,GAAGigB,WAAW,EAAE,GAAGC,UAAU,CAAC,GAAG,aAAa,GAAI/gB,KAAK,CAAC;EAC3F,CAAC;;EAED;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,MAAMmhB,qBAAqB,GAAG,CAAC;EAC/B,MAAMC,aAAa;EACjB,CAACd,IAAI,CAAChb,OAAO,IAAIgb,IAAI,CAAChb,OAAO,CAACE,SAAS,KAAK,SAAS,IAAIuH,eAAe,CAACuT,IAAI,CAACe,cAAc,CAAC;EAC/F,MAAMC,aAAa,GAAGvU,eAAe,CAACuT,IAAI,CAACe,cAAc,CAAC,GAAGF,qBAAqB,GAAG,CAAC,GAAG,CAAC;EAC1F,OAAOvV,MAAM,CAAC3D,GAAG,CAAC,CAACsK,CAAC,EAAEpK,CAAC,KAAK;IAC1B,MAAMhD,QAAQ,GAAGmb,IAAI,CAACnb,QAAQ;IAC1Bqc,gBAAgB,CAACR,cAAc,CAACV,IAAI,CAACnb,QAAQ,EAAEgD,CAAC,CAAC,EA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"}